<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heapsort Visualization</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the tree visualization */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
        }

        /* --- Global Zoom (Removed) --- */
        #app {
	    transform: scale(0.8);
            transform-origin: top center; /* This is the key line */
            /* The width will be set dynamically in renderState based on tree size */
            transition: min-width 0.3s ease;
            /* Added mx-auto back to center content when width is small */
            margin-left: auto;
            margin-right: auto;
        }
        
        /* --- Tree Specific Styles --- */
        #heap-container {
            /* Set to relative to contain the wrapper div */
            position: relative;
            /* Min-height ensures the container doesn't collapse when the tree is small */
            min-height: 550px; 
            padding-top: 20px;
        }

        .heap-node {
            transition: all 0.5s ease-in-out;
            cursor: pointer;
            user-select: none;
            position: absolute; /* Absolute positioning for tree layout, relative to centered wrapper */
            width: 48px; /* w-12 */
            height: 48px; /* h-12 */
            border-radius: 9999px; /* rounded-full */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            z-index: 10; /* Ensure nodes are on top of lines */
        }

        .heap-line {
            position: absolute; /* Absolute positioning, relative to centered wrapper */
            height: 2px; /* Line thickness */
            background-color: #9ca3af; /* gray-400 */
            transform-origin: 0 0; /* Rotate from the parent end */
            z-index: 5; /* Keep lines behind nodes */
            transition: all 0.5s ease-in-out;
        }

        /* --- Highlight classes --- */
        .highlight-compare {
            background-color: #fcd34d !important; /* Yellow */
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(252, 211, 77, 0.8);
        }

        .highlight-swap {
            background-color: #ef4444 !important; /* Red */
            color: white;
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.9);
        }

        .highlight-sorted {
            background-color: #10b981 !important; /* Green */
            color: white;
            opacity: 0.7;
        }

        .highlight-root {
            background-color: #3b82f6 !important; /* Blue */
            color: white;
            transform: scale(1.2);
        }

        /* Hide scrollbars for a cleaner look */
        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .hide-scrollbar {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        /* --- Heap Complete Message Style --- */
        #heap-complete-message {
            position: fixed; 
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5000; /* Extremely high z-index */
            transition: opacity 0.3s ease-in-out;
            pointer-events: none;
        }
        
        /* Apply transition and semi-transparent background (Indigo-600 is 79, 70, 229) */
        .message-content {
            transition: opacity 0.35s ease-in-out, transform 0.35s ease-in-out;
            /* Using RGBA for semi-transparency (55% opacity) */
            background-color: rgba(79, 70, 229, 0.55); 
        }

    </style>
</head>
<body class="p-4 md:p-8">

    <div id="app" class="mx-auto bg-white shadow-xl rounded-xl p-6 md:p-10">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 border-b pb-2">Heapsort Visualizer</h1>

        <!-- Controls (Top Section) -->
        <div class="flex flex-wrap gap-4 items-center justify-between mb-8 p-4 bg-gray-50 rounded-lg shadow-inner">
            <div class="flex items-center gap-4">
                <label for="arraySize" class="text-sm font-medium text-gray-700 whitespace-nowrap">Array Size (N):</label>
                <input type="number" id="arraySize" value="25" min="5" max="50" class="w-20 p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                <button onclick="init()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline mr-1" viewBox="0 0 20 20" fill="currentColor"><path d="M4 3a2 2 0 100 4h12a2 2 0 100-4H4z"></path><path fill-rule="evenodd" d="M3 8h14v7a2 2 0 01-2 2H5a2 2 0 01-2-2V8zm5 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" clip-rule="evenodd"></path></svg>
                    Generate New Array
                </button>
            </div>

            <div class="flex items-center space-x-4">
                <span class="text-sm font-medium text-gray-700">Sort Order:</span>
                <button id="sortOrderToggle" onclick="toggleSortOrder()" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                    Ascending (Max-Heap)
                </button>
            </div>
        </div>

        <!-- Status and Explanation (Removed from here - see below tree) -->
        <div id="status" class="hidden"></div>
        <div id="explanation" class="hidden"></div>

        <!-- Array Visualization -->
        <h2 class="text-2xl font-semibold text-gray-800 mb-4 mt-6">Input Array (Original Unsorted Data)</h2>
        <div id="array-container" class="flex flex-wrap justify-center gap-1.5 p-4 bg-gray-100 rounded-lg shadow-md hide-scrollbar overflow-x-auto">
            <!-- Array elements will be rendered here -->
        </div>
        
        <!-- Output Array Visualization -->
        <h2 class="text-2xl font-semibold text-gray-800 mb-4 mt-8">Sorted Output Array (<span class="text-green-600">Fixed</span> elements are shown)</h2>
        <div id="output-array-container" class="flex flex-wrap justify-center gap-1.5 p-4 bg-green-100 rounded-lg shadow-md min-h-[50px]">
            <!-- Output elements will be rendered here -->
        </div>

        <!-- Heap Tree Visualization -->
        <h2 class="text-2xl font-semibold text-gray-800 mb-4 mt-8">Heap Structure (Tree View - Active Elements Only)</h2>
        <div id="heap-container" class="w-full overflow-x-auto pb-0">
            <!-- Tree nodes and lines will be rendered here -->
        </div>
        
        <!-- Heap Complete Message Overlay -->
        <div id="heap-complete-message" class="hidden">
            <div id="message-content" class="message-content text-white px-10 py-5 rounded-xl shadow-2xl border-4 border-white transform scale-105 opacity-0">
                <div id="message-title" class="text-4xl font-extrabold"></div>
                <div id="message-subtitle" class="text-lg font-medium mt-2"></div>
            </div>
        </div>
        
        <!-- Algorithm Controls (MOVED UP) -->
        <div class="flex flex-wrap gap-3 mb-6 items-center justify-center p-4 bg-white rounded-lg border mt-2">
            <!-- UPDATED RESET BUTTON -->
            <button id="resetBtn" onclick="resetState()" class="bg-red-500 text-white font-semibold py-3 px-8 rounded-full shadow-xl hover:bg-red-600 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <span class="text-xl font-bold align-middle mr-2">↺</span>
                <span id="resetText">Reset</span>
            </button>
            <button id="prevBtn" onclick="prevStep()" disabled class="bg-gray-400 text-white font-semibold py-2 px-4 rounded-full shadow-lg hover:bg-gray-500 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>
            </button>
            <button id="playBtn" onclick="playPause()" disabled class="bg-green-600 text-white font-semibold py-3 px-8 rounded-full shadow-xl hover:bg-green-700 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path></svg>
                <span id="playText">Play</span>
            </button>
            <button id="nextBtn" onclick="nextStep()" disabled class="bg-gray-800 text-white font-semibold py-2 px-4 rounded-full shadow-lg hover:bg-gray-900 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg>
            </button>
        </div>
        
        <!-- Status and Explanation (MOVED HERE) -->
        <div id="status-moved" class="text-center mb-6 mt-8 text-lg font-bold text-indigo-700 min-h-[30px]"></div>
        <div id="explanation-moved" class="text-center mb-8 text-base font-medium text-gray-600 min-h-[30px]"></div>
        
    </div>

    <script>
        const ARRAY_SIZE_DEFAULT = 25;
        let data = []; // Permanent: Holds the original, unsorted input data
        let history = [];
        let currentStep = -1;
        let isPlaying = false;
        let animationInterval = null;
        let isAscending = true; // true: Max-Heap (Ascending sort); false: Min-Heap (Descending sort)
        let isPausedForMessage = false; // Tracks if the animation is paused solely for the message

        const appContainer = document.getElementById('app'); // Get the app container reference
        const arrayContainer = document.getElementById('array-container');
        const heapContainer = document.getElementById('heap-container');
        const outputArrayContainer = document.getElementById('output-array-container');
        const heapCompleteMessage = document.getElementById('heap-complete-message'); 
        const messageContent = document.getElementById('message-content');
        const messageTitle = document.getElementById('message-title');
        const messageSubtitle = document.getElementById('message-subtitle');
        
        // Status elements
        const statusEl = document.getElementById('status-moved');
        const explanationEl = document.getElementById('explanation-moved');
        
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const playBtn = document.getElementById('playBtn');
        const playText = document.getElementById('playText');
        const resetBtn = document.getElementById('resetBtn');
        const resetText = document.getElementById('resetText'); 
        const playIcon = document.getElementById('playIcon');
        const sortOrderToggle = document.getElementById('sortOrderToggle');
        const arraySizeInput = document.getElementById('arraySize');

        // Tree visualization constants (Updated for Aesthetic Spacing)
        const NODE_SIZE = 48; 
        const NODE_RADIUS = NODE_SIZE / 2;
        const LEVEL_HEIGHT = 100; // Vertical distance between levels (kept at 100)
        const BASE_H_UNIT = 25; // Base unit for horizontal spacing on the deepest level
        const HORIZONTAL_MARGIN = 0; 

        // --- Core Algorithm Logic (Heapsort) ---

        /**
         * Logs the current state of the array and the action to the history array.
         */
        function logState(action, highlightNodes = [], phase = 'BUILD_HEAP', heapSize = data.length, sortedIndices = [], rootIndex = -1, workingData = [], status = '') {
            history.push({
                initialArray: [...data], 
                workingArray: [...workingData], 
                action,
                highlightNodes,
                phase,
                heapSize,
                sortedIndices: [...sortedIndices],
                rootIndex,
                status
            });
        }

        /**
         * The standard `heapify` operation (max or min) to maintain the heap property.
         */
        async function heapify(i, n, workingData, callerPhase) {
            let largestOrSmallest = i;
            const left = 2 * i + 1;
            const right = 2 * i + 2;

            // Comparison function uses workingData
            const isCorrectOrder = (a, b) => isAscending ? (workingData[a] > workingData[b]) : (workingData[a] < workingData[b]);
            
            const currentState = history.length > 0 ? history[history.length - 1] : { phase: callerPhase, sortedIndices: [], rootIndex: -1 };

            // Find the candidate (largest or smallest) among parent and children
            if (left < n && isCorrectOrder(left, largestOrSmallest)) {
                largestOrSmallest = left;
            }
            if (right < n && isCorrectOrder(right, largestOrSmallest)) {
                largestOrSmallest = right;
            }
            
            // Log the comparison/decision (dominant operation)
            if (left < n || right < n) {
                let highlightIndices = [i];
                if (left < n) highlightIndices.push(left);
                if (right < n) highlightIndices.push(right);
                
                // Get the value of the parent node
                const parentValue = workingData[i];

                logState(`Deciding largest/smallest among parent ${parentValue} and children.`, highlightIndices, currentState.phase, n, currentState.sortedIndices, currentState.rootIndex, workingData);
            }

            // If the root is not the largest/smallest, swap and continue heapifying
            if (largestOrSmallest !== i) {
                const parentValue = workingData[i];
                const swapValue = workingData[largestOrSmallest];

                // Log the swap (dominant operation), referring to values
                logState(`Swapping value ${parentValue} and ${swapValue}.`, [i, largestOrSmallest], currentState.phase, n, currentState.sortedIndices, currentState.rootIndex, workingData);
                
                [workingData[i], workingData[largestOrSmallest]] = [workingData[largestOrSmallest], workingData[i]]; 
                
                await heapify(largestOrSmallest, n, workingData, callerPhase);
            }

            // --- CRUCIAL: Log the completion of the entire heapify branch ---
            // This is logged only if the call originated from the main loop (i=0) during the SORTING phase
            if (i === 0 && callerPhase === 'SORTING') {
                logState(`Heap maintenance cycle complete.`, [i], callerPhase, n, currentState.sortedIndices, currentState.rootIndex, workingData, 'HEAP_MAINTENANCE_COMPLETE');
            }
        }

        /**
         * Runs the Heapsort algorithm on a copy of the input array.
         */
        async function heapsort(workingData) {
            const n = workingData.length;
            let phase = 'BUILD_HEAP';

            // 1. Build Heap (Phase 1)
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                await heapify(i, n, workingData, phase);
            }

            // --- LOG THE INITIAL HEAP BUILD COMPLETION (First Pause) ---
            logState('The initial heap structure is complete.', [], 'BUILD_COMPLETE', n, [], -1, workingData, 'BUILD_COMPLETE_MESSAGE');

            // 2. Sort/Extract (Phase 2)
            phase = 'SORTING';
            let sortedIndices = [];

            for (let i = n - 1; i > 0; i--) {
                const rootValue = workingData[0];
                const lastHeapValue = workingData[i];

                // Log 1: Highlight the impending swap/extraction (Step 1 of the extraction)
                logState(`Extracting root (${rootValue}) and placing value ${lastHeapValue} at the root.`, [0, i], phase, i + 1, sortedIndices, 0, workingData);
                
                // Perform swap in the working array
                [workingData[0], workingData[i]] = [workingData[i], workingData[0]];

                // Mark the newly placed element as sorted
                sortedIndices.push(i);

                // --- Log 2: Show result of extraction, reflecting the reduced heap size 'i' and the newly sorted element. ---
                const extractedValue = workingData[i]; // Value is now at the fixed position i
                logState(`Element ${extractedValue} fixed in sorted position. Heap size reduced to ${i}.`, [i], phase, i, sortedIndices, -1, workingData);

                // Heapify the reduced heap (size i)
                await heapify(0, i, workingData, phase);
            }

            // Mark the last element (index 0) as sorted
            sortedIndices.push(0);
            logState('Heapsort Complete! The array is sorted.', [], 'FINISHED', 0, sortedIndices, -1, workingData);
        }

        // --- Visualization Helpers ---

        function getNodeCoordinates(index, totalNodes) {
            const numLevels = Math.ceil(Math.log2(totalNodes + 1));
            const level = Math.floor(Math.log2(index + 1));
            const maxBottomNodes = Math.pow(2, numLevels - 1);
            const levelMultiplier = Math.pow(2, numLevels - 1 - level);
            const posInLevel = index - (Math.pow(2, level) - 1);
            const totalDiagramWidth = (maxBottomNodes * 2 * BASE_H_UNIT);
            const startSlot = posInLevel * levelMultiplier * 2;
            const centerSlot = startSlot + levelMultiplier; 
            const x = HORIZONTAL_MARGIN + centerSlot * BASE_H_UNIT; 
            const y = (level * LEVEL_HEIGHT) + NODE_RADIUS;

            return { x, y, totalDiagramWidth };
        }

        function createLine(p1, p2) {
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * (180 / Math.PI);

            const angleRad = angle * (Math.PI / 180);
            const startX = p1.x + NODE_RADIUS * Math.cos(angleRad);
            const startY = p1.y + NODE_RADIUS * Math.sin(angleRad);
            const lineLength = Math.max(0, length - (2 * NODE_RADIUS));

            return `
                <div class="heap-line" style="
                    left: ${startX}px;
                    top: ${startY}px;
                    width: ${lineLength}px;
                    transform: rotate(${angle}deg);
                "></div>
            `;
        }

        function renderHeapTree(arr, state) {
            const N_original = state.initialArray.length;
            const N_active = state.heapSize; 
            
            const numLevels = Math.ceil(Math.log2(N_original + 1));
            const maxBottomNodes = Math.pow(2, numLevels - 1);
            const maxTotalWidth = (maxBottomNodes * 2 * BASE_H_UNIT);

            let treeContentHtml = '';

            // 1. Draw lines (only between active heap nodes)
            for (let i = 0; i < N_active; i++) {
                const parentCoords = getNodeCoordinates(i, N_original);
                const leftChildIndex = 2 * i + 1;
                const rightChildIndex = 2 * i + 2;

                if (leftChildIndex < N_active) {
                    const childCoords = getNodeCoordinates(leftChildIndex, N_original);
                    treeContentHtml += createLine(parentCoords, childCoords);
                }
                if (rightChildIndex < N_active) {
                    const childCoords = getNodeCoordinates(rightChildIndex, N_original);
                    treeContentHtml += createLine(parentCoords, childCoords);
                }
            }
            
            // 2. Render Nodes (only for active heap nodes)
            for (let i = 0; i < N_active; i++) {
                const val = arr[i];
                const coords = getNodeCoordinates(i, N_original);

                let classes = 'heap-node font-mono text-sm transition-all duration-500 bg-indigo-100 text-indigo-800';

                // Apply highlights based on state
                if (state.highlightNodes.includes(i)) {
                    const isSwap = state.action.includes('Swapping') || state.action.includes('Extracting');
                    classes = isSwap ? classes.replace('bg-indigo-100', 'bg-red-500 text-white highlight-swap') : classes.replace('bg-indigo-100', 'bg-yellow-400 text-gray-800 highlight-compare');
                } else if (state.rootIndex === i && state.phase === 'SORTING') {
                    classes = classes.replace('bg-indigo-100', 'bg-blue-600 text-white highlight-root');
                }
                
                treeContentHtml += `
                    <div class="${classes}" style="
                        left: ${coords.x - NODE_RADIUS}px;
                        top: ${coords.y - NODE_RADIUS}px;
                    ">
                        <span class="text-lg font-bold">${val}</span>
                        <span class="text-xs font-normal opacity-70">i=${i}</span>
                    </div>
                `;
            }

            heapContainer.style.minHeight = `${(numLevels * LEVEL_HEIGHT) + 50}px`;

            // 3. Wrap content in a centered div
            return `
                <div class="relative" id="tree-wrapper" style="width: ${maxTotalWidth}px; margin: 0 auto; height: 100%;">
                    ${treeContentHtml}
                </div>
            `;
        }


        // --- General Control Functions ---

        function generateRandomArray(N) {
            data = [];
            for (let i = 0; i < N; i++) {
                data.push(Math.floor(Math.random() * 90) + 10); // Numbers between 10 and 99
            }
        }

        function init() {
            stopAnimation();

            const N = parseInt(arraySizeInput.value) || ARRAY_SIZE_DEFAULT;
            if (N < 5 || N > 50) {
                console.error('Error: Array size must be between 5 and 50.');
                arraySizeInput.value = ARRAY_SIZE_DEFAULT;
                return;
            }
            arraySizeInput.value = N;

            generateRandomArray(N);
            history = [];
            currentStep = -1;

            // Log initial state
            logState('Initial Random Array', [], 'INITIAL', N, [], -1, [...data]); // Pass initial data as workingData for Step 0

            // Run the algorithm to populate the history on a COPY of the data
            (async () => {
                await heapsort([...data]); 
                currentStep = 0;
                renderState();
                playBtn.disabled = false;
            })();
        }
        
        function resetState() {
            stopAnimation();
            if (history.length > 0) {
                currentStep = 0;
                renderState();
            }
        }

        function toggleSortOrder() {
            isAscending = !isAscending;
            sortOrderToggle.textContent = isAscending ? 'Ascending (Max-Heap)' : 'Descending (Min-Heap)';
            sortOrderToggle.classList.toggle('bg-blue-500', isAscending);
            sortOrderToggle.classList.toggle('bg-red-500', !isAscending);
            init(); // Re-initialize with the new order
        }

        function nextStep() {
            if (currentStep < history.length - 1) {
                
                const state = history[currentStep + 1];

                // If currently paused for the message, clicking nextStep skips the delay
                if (isPausedForMessage) {
                    isPausedForMessage = false;
                    // We need to move past the paused step now
                    currentStep++; 
                    // And if playing, restart the animation interval
                    if (isPlaying) {
                        startAnimation();
                    }
                } else {
                    currentStep++;
                }
                
                renderState();

                // Check if the next step is a point where the heap is complete/maintained, and we are playing
                const isMajorHeapCompletion = state && (state.status === 'BUILD_COMPLETE_MESSAGE' || state.status === 'HEAP_MAINTENANCE_COMPLETE');
                
                if (isMajorHeapCompletion && isPlaying) {
                    isPausedForMessage = true;
                    clearInterval(animationInterval);
                    
                    // Automatically resume playback after the required delay
                    setTimeout(() => {
                        // Check if the user hasn't manually paused or reset during the wait
                        if (isPlaying && isPausedForMessage) { 
                            isPausedForMessage = false;
                            nextStep(); // Advance past the paused step
                            startAnimation(); // Restart the interval
                        } else {
                            // If they stopped or reset, just ensure the message is gone
                            renderState(); 
                        }
                    }, 1000); // 1.0 seconds pause
                }
            } else {
                stopAnimation();
            }
        }

        function prevStep() {
            if (currentStep > 0) {
                // If moving backwards out of a paused state, ensure animation is stopped
                if (history[currentStep].status === 'BUILD_COMPLETE_MESSAGE' || history[currentStep].status === 'HEAP_MAINTENANCE_COMPLETE' && isPlaying) {
                    stopAnimation();
                }
                currentStep--;
                renderState();
            }
        }

        function playPause() {
            if (isPlaying) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }

        function startAnimation() {
            isPlaying = true;
            playText.textContent = 'Pause';
            playIcon.innerHTML = `<path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path>`; // Pause icon

            animationInterval = setInterval(() => {
                if (currentStep < history.length - 1) {
                    nextStep();
                } else {
                    stopAnimation();
                }
            }, 200); 
            // Rerender to ensure buttons are updated immediately upon starting play
            renderState(); 
        }

        function stopAnimation() {
            isPlaying = false;
            isPausedForMessage = false; // Clear any pending message pause
            playText.textContent = 'Play';
            playIcon.innerHTML = `<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path>`; // Play icon
            clearInterval(animationInterval);
            
            // Rerender to ensure buttons are updated immediately upon stopping play
            renderState(); 
        }

        /**
         * Renders the current state of the arrays and the heap tree.
         */
        function renderState() {
            if (history.length === 0 || currentStep < 0) return;

            const state = history[currentStep];
            const initialArr = state.initialArray; // The fixed, original array
            const workingArr = state.workingArray; // The array being sorted
            const N = initialArr.length; 

            // --- Update UI Controls ---
            const isPausedByMe = isPausedForMessage && isPlaying;
            prevBtn.disabled = currentStep === 0 || isPlaying && !isPausedByMe; 
            nextBtn.disabled = currentStep === history.length - 1 || isPlaying && !isPausedByMe;
            playBtn.disabled = state.phase === 'FINISHED';
            resetBtn.disabled = isPlaying && !isPausedByMe; 

            // --- Control Heap Complete Message Visibility (FIXED) ---
            const isMajorHeapCompletion = state.status === 'BUILD_COMPLETE_MESSAGE' || state.status === 'HEAP_MAINTENANCE_COMPLETE';

            if (isMajorHeapCompletion) {
                let title = '';
                let subtitle = '';

                if (state.status === 'BUILD_COMPLETE_MESSAGE') {
                    // UPDATED MESSAGE FOR CLARITY
                    title = "INITIAL HEAP CONSTRUCTED!";
                    subtitle = "The O(N) heap construction phase is complete. Sorting (extraction) begins now.";
                } else if (state.status === 'HEAP_MAINTENANCE_COMPLETE') {
                    title = "HEAP MAINTAINED!"; 
                    subtitle = "Swapping root and last leaf and pruning...";
                }
                
                messageTitle.textContent = title;
                messageSubtitle.textContent = subtitle;
                
                heapCompleteMessage.classList.remove('hidden');
                
                // Use requestAnimationFrame to ensure repaint occurs before transition starts
                requestAnimationFrame(() => {
                    messageContent.classList.remove('opacity-0');
                    messageContent.classList.add('opacity-100', 'scale-105'); 
                });
            } else {
                // Start fade-out transition by removing opacity
                messageContent.classList.remove('opacity-100', 'scale-105');
                messageContent.classList.add('opacity-0');
                
                // Wait for transition to finish (350ms for safety) before applying 'hidden'
                setTimeout(() => {
                    // Only hide the parent if the message is indeed faded out
                    if (messageContent.classList.contains('opacity-0')) {
                        heapCompleteMessage.classList.add('hidden');
                    }
                }, 350);
            }
            // ------------------------------------------------

            // --- Update Status and Explanation ---
            let statusText = '';
            let explanationHtml = '';
            let phaseDescription = isAscending ? 'Max-Heap' : 'Min-Heap';

            if (state.phase === 'INITIAL') {
                statusText = 'Phase 0: Initial State';
                explanationHtml = `Step ${currentStep + 1} of ${history.length}. Action: ${state.action}`;
            }
            else if (state.phase === 'BUILD_HEAP') {
                statusText = `Phase 1: Building ${phaseDescription} (${state.heapSize} elements)`;
                explanationHtml = `Step ${currentStep + 1} of ${history.length}. Action: ${state.action}`;
            }
            else if (state.status === 'BUILD_COMPLETE_MESSAGE') {
                 statusText = `Phase 1 Complete: ${phaseDescription} Built`;
                explanationHtml = `Step ${currentStep + 1} of ${history.length}. <b>INITIAL HEAP CONSTRUCTED!</b> ${isPausedByMe ? "Auto-resuming in 1.0s or click 'Next Step'." : ""}`;
            }
            else if (state.phase === 'SORTING') {
                statusText = `Phase 2: Extracting Root and Sorting (Heap Size: ${state.heapSize})`;
                explanationHtml = `Step ${currentStep + 1} of ${history.length}. Action: ${state.action}`;
            }
            else if (state.status === 'HEAP_MAINTENANCE_COMPLETE') {
                statusText = `Phase 2: Heap Maintenance Complete`;
                explanationHtml = `Step ${currentStep + 1} of ${history.length}. <b>HEAP MAINTAINED!</b> The next step will extract the new root. ${isPausedByMe ? "Auto-resuming in 1.0s or click 'Next Step'." : ""}`;
            }
            else if (state.phase === 'FINISHED') {
                statusText = 'Algorithm Complete! Array is Sorted.';
                
                // Complexity Calculation
                const actualSteps = history.length;
                const NLogN = (N * Math.log2(N)); 
                const NLogN_Rounded = NLogN.toFixed(0);
                
                explanationHtml = `
                    The Heapsort algorithm has finished in <b>${actualSteps} steps</b> (recorded dominant operations).
                    <br>
                    The theoretical time complexity is <b>O(N log N)</b>. 
                    <br>
                    For N=${N}, the complexity factor (N log₂ N) is approximately <b>${NLogN_Rounded}</b>. The recorded steps are expected to be proportional to this factor.
                `;
            }

            statusEl.textContent = statusText;
            explanationEl.innerHTML = explanationHtml; 

            // --- Value-Based Highlighting Setup ---
            // Get the values currently fixed in the sorted section of the working array
            const sortedValues = state.sortedIndices.map(i => workingArr[i]);
            const consumedSortedValues = [...sortedValues]; // Copy to consume for one-to-one mapping

            // --- Render Input Array (Static, Value-Based Highlighting) ---
            arrayContainer.innerHTML = initialArr.map((val, i) => {
                let classes = 'flex flex-col items-center justify-center p-2 rounded-lg font-mono text-sm shadow-md transition-all duration-500 w-10 h-10 bg-gray-200 text-gray-800';
                
                // Find if the current value exists in the consumedSortedValues list
                const valueIndex = consumedSortedValues.indexOf(val);

                if (valueIndex !== -1) {
                    // If found, apply green highlight and consume the value from the list
                    classes = classes.replace('bg-gray-200', 'bg-green-600 text-white highlight-sorted');
                    consumedSortedValues.splice(valueIndex, 1); // Consume it so duplicates aren't over-highlighted
                }

                return `
                    <div class="${classes}">
                        <span class="font-bold">${val}</span>
                        <span class="text-xs opacity-70">i=${i}</span>
                    </div>
                `;
            }).join('');

            // --- Render Output Array ---
            const outputElements = [];
            
            for (let i = 0; i < N; i++) {
                let val = '';
                let classes = 'flex items-center justify-center p-2 rounded-lg font-mono text-lg font-bold shadow-md w-10 h-10 bg-gray-300 text-gray-800 opacity-30';

                if (state.sortedIndices.includes(i)) {
                    // Use the value from the sorted position in the working array
                    val = workingArr[i]; 
                    classes = 'flex items-center justify-center p-2 rounded-lg font-mono text-lg font-bold shadow-md w-10 h-10 bg-green-600 text-white transition-all duration-500';
                } else {
                    val = '-';
                }

                outputElements.push(`
                    <div class="${classes}">
                        ${val}
                    </div>
                `);
            }
            outputArrayContainer.innerHTML = outputElements.join('');

            // --- Render Heap Tree ---
            heapContainer.innerHTML = renderHeapTree(workingArr, state);

            // -----------------------------------------------------------------------------------
            // Dynamic Width Adjustment based on Tree Size
            const numLevels = Math.ceil(Math.log2(N + 1));
            const maxBottomNodes = Math.pow(2, numLevels - 1);
            const requiredWidth = (maxBottomNodes * 2 * BASE_H_UNIT);
            
            // Set minimum width for the entire application wrapper (#app)
            appContainer.style.minWidth = `${requiredWidth + 300}px`; 
            // -----------------------------------------------------------------------------------
        }

        // Initialize on load
        window.onload = function() {
            init();
        };

    </script>
</body>
</html>
