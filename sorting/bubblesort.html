<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bubble Sort Visualiser</title>
    <script src="https://cdn.tailwindcss.com"></script>
    /* <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"> */
    <link href="style_b.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        /* Custom styles for bricks */
        .brick {
            /* Base transition for movement */
            transition: all 0.15s ease-in-out, background-color 0.15s ease-in-out;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.875rem;
            font-weight: 500;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
            border-radius: 0.375rem; /* rounded-md */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        /* Class for the comparing state */
        .comparing {
            filter: brightness(0.7);
        }
        /* Class for the swapping state */
        .swapping {
            background-color: #FBBF24 !important; /* Tailwind 'yellow-400' */
            transform: translateY(-10px);
            /* Use a faster transition for the swap itself */
            transition: transform 0.1s ease-in-out, background-color 0.1s ease-in-out;
        }
        /* Class for the sorted state */
        .sorted {
            filter: brightness(1.2) saturate(0.8);
        }

        /* Flex container for horizontal summary stats */
        .stats-summary-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            width: 100%;
            gap: 1rem;
        }
        .stats-summary-cell {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
            min-width: 120px;
        }
        .stats-summary-cell span:first-child {
            font-size: 0.75rem;
            font-weight: 500;
            color: #4b5563; /* text-gray-600 */
            text-transform: uppercase;
        }
        .stats-summary-cell span:last-child {
            font-size: 1.125rem;
            font-weight: 700;
            color: #1f2937; /* text-gray-800 */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="max-w-6xl w-full bg-white p-6 rounded-xl shadow-2xl">
        <header class="text-center mb-6">
            <h1 class="text-3xl font-bold text-gray-800">Bubble Sort Visualiser</h1>
        </header>

        <div id="visualisation-area" class="w-full min-h-[150px] flex items-end justify-center gap-1 p-4 mb-4 border border-gray-200 rounded-lg bg-gray-50 shadow-inner overflow-x-auto">
            </div>

        <div class="bg-white p-4 rounded-lg shadow-inner border border-gray-200 mb-4">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                <div class="bg-gray-50 border border-gray-200 rounded-lg p-2">
                    <label for="n-input" class="block text-sm font-medium text-gray-500 mb-1 text-center">N (elements)</label>
                    <input type="number" id="n-input" value="10" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-center">
                </div>
                <div class="md:col-span-3 bg-gray-50 border border-gray-200 rounded-lg p-2">
                    <label for="array-input" class="block text-sm font-medium text-gray-500 mb-1 text-center">Array (comma-separated)</label>
                    <input type="text" id="array-input" class="w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>

            <div class="grid grid-cols-3 sm:grid-cols-7 gap-2">
                 <button id="random-btn" class="w-full bg-blue-600 text-white py-1 px-4 rounded-md shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-150">
                    Random
                </button>
                <button id="worst-case-btn" class="w-full bg-blue-600 text-white py-1 px-4 rounded-md shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-150">
                    Worst Case
                </button>
                <button id="best-case-btn" class="w-full bg-blue-600 text-white py-1 px-4 rounded-md shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-150">
                    Best Case
                </button>
                <button id="back-btn" class="w-full bg-gray-500 text-white py-1 px-4 rounded-md shadow-sm hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition duration-150" disabled>
                    Back
                </button>
                 <button id="play-btn" class="w-full bg-blue-500 text-white py-1 px-4 rounded-md shadow-sm hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition duration-150">
                    Play
                </button>
                 <button id="next-step-btn" class="w-full bg-green-600 text-white py-1 px-4 rounded-md shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition duration-150">
                    Next Step
                </button>
                <button id="reset-btn" class="w-full bg-red-600 text-white py-1 px-4 rounded-md shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition duration-150">
                    Reset
                </button>
            </div>
        </div>

        <div id="status-log" class="text-gray-600 font-medium mb-4 h-32 p-2 border border-gray-200 rounded-lg bg-gray-50 flex justify-center items-center overflow-hidden">
            Generate an array or enter one manually.
        </div>

        <div id="stats-container" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4 text-center">
            <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                <div class="text-sm font-medium text-gray-500 mb-1">Iteration</div>
                <div id="iteration-count" class="text-2xl font-bold text-gray-800">0</div>
            </div>
            <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                <div class="text-sm font-medium text-gray-500 mb-1">Iteration Swaps</div>
                <div id="iteration-swaps" class="text-2xl font-bold text-gray-800">0</div>
            </div>
            <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                <div class="text-sm font-medium text-gray-500 mb-1">Total Comparisons</div>
                <div id="total-comparisons" class="text-2xl font-bold text-gray-800">0</div>
            </div>
            <div class="bg-gray-50 border border-gray-200 rounded-lg p-3">
                <div class="text-sm font-medium text-gray-500 mb-1">Total Swaps</div>
                <div id="total-swaps" class="text-2xl font-bold text-gray-800">0</div>
            </div>
        </div>

    </div>

    <script>
        // DOM Elements
        const nInput = document.getElementById('n-input');
        const arrayInput = document.getElementById('array-input');
        const randomBtn = document.getElementById('random-btn');
        const worstCaseBtn = document.getElementById('worst-case-btn');
        const bestCaseBtn = document.getElementById('best-case-btn');
        const nextStepBtn = document.getElementById('next-step-btn');
        const resetBtn = document.getElementById('reset-btn');
        const playBtn = document.getElementById('play-btn');
        const backBtn = document.getElementById('back-btn');
        const visualisationArea = document.getElementById('visualisation-area');
        const statusLog = document.getElementById('status-log');

        // Stat Displays
        const iterationCountDisplay = document.getElementById('iteration-count');
        const iterationSwapsDisplay = document.getElementById('iteration-swaps');
        const totalComparisonsDisplay = document.getElementById('total-comparisons');
        const totalSwapsDisplay = document.getElementById('total-swaps');

        // Algorithm State
        let array = [];
        let elementCount = 10; // Main count, from nInput
        let i = 0; // Outer loop (iterations)
        let j = 0; // Inner loop (comparisons)
        let iterationSwaps = 0;
        let totalSwaps = 0;
        let totalComparisons = 0;
        let isSorting = false;
        let sortCompleted = false;
        let isPlaying = false;
        
        let playInterval; 
        let currentTimeout; 

        // History for "Back" button
        let history = [];

        // Constants
        const PLAY_INTERVAL_DELAY = 150; // ms between steps
        const ANIMATION_DELAY = 100; // ms for swap animation
        const MIN_BRICK_HEIGHT_PX = 5; // 5px min height
        const MAX_BRICK_HEIGHT_PERCENT = 1.0; // 100% of container
        const MIN_BRICK_HEIGHT_PERCENT = 0.2; // 20% of container
        
        // --- UTILITY FUNCTIONS (Moved up for hoisting fix) ---

        function updateStatus(message) {
            if (!sortCompleted) {
                statusLog.innerHTML = message;
                statusLog.classList.remove('text-center');
            }
        }

        function updateStats() {
            iterationCountDisplay.textContent = i + 1; // Display 1-based index
            iterationSwapsDisplay.textContent = iterationSwaps;
            totalComparisonsDisplay.textContent = totalComparisons;
            totalSwapsDisplay.textContent = totalSwaps;
        }
        
        function disableControls(isPlayMode = false) {
            randomBtn.disabled = true;
            worstCaseBtn.disabled = true;
            bestCaseBtn.disabled = true;
            nInput.disabled = true;
            arrayInput.disabled = true;

            if (isPlayMode) {
                nextStepBtn.disabled = true;
                backBtn.disabled = true;
                playBtn.disabled = false; 
                resetBtn.disabled = false; 
            } else {
                playBtn.disabled = false;
                resetBtn.disabled = false;
            }
        }
        
        function enableControls() {
            const arrayModificationAllowed = !isSorting || sortCompleted || !isPlaying;

            randomBtn.disabled = !arrayModificationAllowed;
            worstCaseBtn.disabled = !arrayModificationAllowed;
            bestCaseBtn.disabled = !arrayModificationAllowed;
            nInput.disabled = !arrayModificationAllowed;
            arrayInput.disabled = !arrayModificationAllowed;

            const executionAllowed = isSorting || (array.length >= 2 && !sortCompleted);

            nextStepBtn.disabled = !executionAllowed || isPlaying; 
            playBtn.disabled = !executionAllowed;
            
            resetBtn.disabled = false;
            backBtn.disabled = history.length <= 1;
            
            if (sortCompleted) {
                nextStepBtn.disabled = true;
                playBtn.disabled = true;
            }
        }

        // --- Initialization ---

        window.onload = () => {
            nInput.addEventListener('change', handleNChange);
            arrayInput.addEventListener('change', handleArrayInputChange);
            
            randomBtn.addEventListener('click', generateRandomArray);
            worstCaseBtn.addEventListener('click', generateWorstCaseArray);
            bestCaseBtn.addEventListener('click', generateBestCaseArray);
            
            resetBtn.addEventListener('click', reset);
            nextStepBtn.addEventListener('click', handleNextClick);
            playBtn.addEventListener('click', handlePlayClick);
            backBtn.addEventListener('click', handleBackClick);

            window.addEventListener('resize', () => drawBricks(array));

            generateArrayAndUpdateUI();
        };

        // --- UI & Array Generation ---

        function handleNChange() {
            elementCount = parseInt(nInput.value); 
            if (elementCount < 2) elementCount = 2;
            if (elementCount > 100) elementCount = 100;
            nInput.value = elementCount;
            generateArrayAndUpdateUI();
        }

        function handleArrayInputChange() {
            try {
                const inputText = arrayInput.value.trim();
                if (inputText === "") {
                    array = [];
                    elementCount = 0; 
                    nInput.value = 0;
                } else {
                    array = inputText.split(',').map(item => {
                        const val = parseInt(item.trim());
                        if (isNaN(val)) throw new Error('Invalid number in array');
                        return val;
                    });
                    elementCount = array.length; 
                    nInput.value = elementCount;
                }
                drawBricks(array);
                resetSortState(); 
                updateStatus('Array loaded. Ready to sort.');
            } catch (error) {
                updateStatus('Error: Invalid array format. Use comma-separated numbers.');
                console.error(error);
            }
        }
        
        function generateRandomArray() {
            generateArrayAndUpdateUI(false, false);
        }

        function generateWorstCaseArray() {
            generateArrayAndUpdateUI(true, false);
        }
        
        function generateBestCaseArray() {
            generateArrayAndUpdateUI(false, true);
        }

        function generateArrayAndUpdateUI(worstCase = false, bestCase = false) {
            array = [];
            let maxVal = elementCount * 5; 
            for (let k = 0; k < elementCount; k++) { 
                array.push(Math.floor(Math.random() * maxVal) + 1);
            }
            
            if (elementCount > 0 && !array.includes(1)) { 
                array[Math.floor(Math.random() * elementCount)] = 1; 
            }

            if (worstCase) {
                array.sort((a, b) => b - a); // Sort descending
            } else if (bestCase) {
                array.sort((a, b) => a - b); // Sort ascending (Best Case)
            }

            arrayInput.value = array.join(', ');
            drawBricks(array);
            resetSortState(); 
            updateStatus('New array generated. Ready to sort.');
        }
        
        function drawBricks(arr) {
            visualisationArea.innerHTML = '';
            if (arr.length === 0) return;
            
            const containerHeight = visualisationArea.clientHeight;
            const maxVal = Math.max(...arr, 1); 
            const minVal = Math.min(...arr, 1);
            const gap = elementCount > 50 ? 0.5 : 1; 
            const containerWidth = visualisationArea.clientWidth;
            const safeContainerWidth = containerWidth > 0 ? containerWidth : 1000;
            const totalGapWidth = (elementCount - 1) * gap; 
            
            arr.forEach((value, index) => {
                const brick = document.createElement('div');
                brick.classList.add('brick');
                brick.id = `brick-${index}`;
                
                const heightRange = MAX_BRICK_HEIGHT_PERCENT - MIN_BRICK_HEIGHT_PERCENT;
                const percentOfMax = ((value - minVal) / (maxVal - minVal || 1)) * heightRange + MIN_BRICK_HEIGHT_PERCENT;
                
                const heightPx = Math.max(MIN_BRICK_HEIGHT_PX, percentOfMax * containerHeight);
                brick.style.height = `${heightPx}px`;
                
                const hue = 240 - (240 * ((value - minVal) / (maxVal - minVal || 1)));
                brick.style.backgroundColor = `hsl(${hue}, 80%, 60%)`;

                brick.style.flexBasis = `0`;
                brick.style.flexGrow = `1`;
                
                brick.textContent = value;
                if ((safeContainerWidth / elementCount) < 20) {
                    brick.textContent = '';
                }
                
                visualisationArea.appendChild(brick);
            });
            
            visualisationArea.style.gap = `${gap}px`;
        }

        // --- Sorting Logic ---

        function handleNextClick() {
            if (sortCompleted || isPlaying) return;
            
            if (!isSorting) {
                startSort();
            } else {
                step();
            }
        }
        
        function handlePlayClick() {
            if (sortCompleted) return;

            if (isPlaying) {
                pause();
            } else {
                if (!isSorting) {
                    startSort();
                }
                play();
            }
        }

        function handleBackClick() {
             if (history.length <= 1) return; 

            if (isPlaying) pause();
            clearTimeout(currentTimeout); 
            currentTimeout = null;
            
            disableControls(true); 

            history.pop();
            const prevState = history[history.length - 1];
            
            array = [...prevState.array];
            i = prevState.i;
            j = prevState.j;
            iterationSwaps = prevState.iterationSwaps;
            totalSwaps = prevState.totalSwaps;
            totalComparisons = prevState.totalComparisons;
            isSorting = prevState.isSorting;
            sortCompleted = prevState.sortCompleted;
            elementCount = prevState.elementCount; 

            arrayInput.value = array.join(', ');
            nInput.value = elementCount; 
            drawBricks(array);
            updateStats();
            
            visualisationArea.querySelectorAll('.brick').forEach(brick => {
                brick.classList.remove('comparing', 'swapping', 'sorted');
            });

            for (let k = (elementCount - i); k < elementCount; k++) { 
                 const brick = document.getElementById(`brick-${k}`);
                 if (brick) brick.classList.add('sorted');
            }

            if (isSorting) {
                highlight(j, j + 1, 'comparing');
                updateStatus(`Rewound. Iteration ${i + 1}. Ready to compare ${array[j]} and ${array[j + 1]}.`);
            } else {
                updateStatus('Rewound to initial state.');
            }
            
            if (sortCompleted) {
                completeSort(); 
            } else {
                enableControls();
            }
        }
        
        function saveState() {
            const state = {
                array: [...array],
                i: i,
                j: j,
                iterationSwaps: iterationSwaps,
                totalSwaps: totalSwaps,
                totalComparisons: totalComparisons,
                isSorting: isSorting,
                sortCompleted: sortCompleted,
                elementCount: elementCount 
            };
            history.push(state);
            enableControls(); 
        }

        function startSort() {
            handleArrayInputChange();
            
            if (array.length < 2) {
                updateStatus("Array is too small to sort.");
                return;
            }
            
            isSorting = true;
            sortCompleted = false;
            
            visualisationArea.querySelectorAll('.brick').forEach(brick => {
                brick.classList.remove('comparing', 'swapping', 'sorted');
            });
            
            history = []; 
            saveState(); 
            
            highlight(j, j + 1, 'comparing');
            updateStatus(`Iteration ${i + 1} (Pass ${i + 1}). Comparing ${array[j]} and ${array[j + 1]}.`);
            updateStats();
            
            disableControls(); 
        }

        function step() {
            if (sortCompleted || !isSorting) return;
            
            if (currentTimeout) return; 

            nextStepBtn.disabled = true;
            backBtn.disabled = true;

            removeHighlight(j, j + 1, 'comparing');

            totalComparisons++;
            let didSwap = false;
            
            if (array[j] > array[j + 1]) {
                didSwap = true;
                totalSwaps++;
                iterationSwaps++;
                
                [array[j], array[j + 1]] = [array[j + 1], array[j]];
                
                updateStatus(`Iteration ${i + 1}. Swapping ${array[j + 1]} and ${array[j]}.`);
                
                animateSwap(j, j + 1, () => {
                    currentTimeout = null; 
                    advancePointers(didSwap);
                });
            } else {
                updateStatus(`Iteration ${i + 1}. No swap (${array[j]} <= ${array[j+1]}).`);
                
                currentTimeout = setTimeout(() => {
                    currentTimeout = null; 
                    advancePointers(didSwap);
                }, isPlaying ? PLAY_INTERVAL_DELAY * 0.5 : ANIMATION_DELAY); 
                
            }
        }
        
        function advancePointers(didSwap) {
            
            enableControls();

            saveState();
            
            j++; 

            // --- 4. Check for End of Iteration ---
            if (j >= elementCount - 1 - i) { 
                
                // Mark the last element as sorted.
                const sortedBrick = document.getElementById(`brick-${elementCount - 1 - i}`); 
                if (sortedBrick) sortedBrick.classList.add('sorted');
                
                // *** CRITICAL FIX HERE: Check for optimised end condition BEFORE advancing i ***
                if (iterationSwaps === 0) {
                    completeSort();
                    return;
                }
                
                // If we reach here, a swap occurred, so we proceed to the next iteration.
                i++; 
                j = 0; // Reset inner loop
                iterationSwaps = 0; // Reset for next iteration

                // Check if sort is fully complete (Worst case)
                if (i >= elementCount - 1) { 
                    completeSort();
                    return;
                }
            }
            
            // --- 5. Ready for Next Step ---
            if (!sortCompleted) {
                highlight(j, j + 1, 'comparing');
                if (array[j] !== undefined && array[j+1] !== undefined) {
                    updateStatus(`Iteration ${i + 1}. Comparing ${array[j]} and ${array[j + 1]}.`);
                }
                updateStats();
            }
        }
        
        function completeSort() {
            isSorting = false;
            sortCompleted = true;
            if (isPlaying) pause(true); 
            
            visualisationArea.querySelectorAll('.brick').forEach(brick => {
                brick.classList.add('sorted');
                brick.classList.remove('comparing', 'swapping');
            });
            
            // If the sort completed early (best case), i will be 0. We display 1 pass.
            const finalIterations = i + 1;
            const totalOps = totalComparisons + totalSwaps;
            
            statusLog.innerHTML = `
                <div class="text-center w-full">
                    <h3 class="text-xl font-bold text-green-700 mb-3">Sort Complete!</h3>
                    <div class="stats-summary-container">
                        <div class="stats-summary-cell">
                            <span>Iterations</span>
                            <span>${finalIterations}</span>
                        </div>
                        <div class="stats-summary-cell">
                            <span>Total Comparisons</span>
                            <span>${totalComparisons}</span>
                        </div>
                        <div class="stats-summary-cell">
                            <span>Total Swaps</span>
                            <span>${totalSwaps}</span>
                        </div>
                        <div class="stats-summary-cell">
                            <span>Total Operations</span>
                            <span>${totalOps}</span>
                        </div>
                    </div>
                    
                    <p class="text-xs text-gray-500 mt-2">(Bubble Sort is O(nÂ²) in average/worst case, O(n) in best case)</p>
                </div>
            `;
            statusLog.classList.add('text-center');

            updateStats();
            saveState(); 
            enableControls();
        }
        
        function reset() {
            if (isPlaying) pause();
            clearTimeout(currentTimeout);
            currentTimeout = null;
            statusLog.innerHTML = "Generate an array or enter one manually.";
            statusLog.classList.remove('text-center');
            handleNChange(); 
        }
        
        function resetSortState() {
            i = 0;
            j = 0;
            iterationSwaps = 0;
            totalSwaps = 0;
            totalComparisons = 0;
            isSorting = false;
            sortCompleted = false;
            history = [];
            
            clearTimeout(currentTimeout); 
            currentTimeout = null;
            if (isPlaying) pause(true); 
            
            updateStats();
            enableControls();
            
            visualisationArea.querySelectorAll('.brick').forEach(brick => {
                brick.classList.remove('comparing', 'swapping', 'sorted');
            });
        }

        // --- Animations & Highlights ---

        function highlight(index1, index2, className) {
            const brick1 = document.getElementById(`brick-${index1}`);
            const brick2 = document.getElementById(`brick-${index2}`);
            if (brick1) brick1.classList.add(className);
            if (brick2) brick2.classList.add(className);
        }

        function removeHighlight(index1, index2, className) {
            const brick1 = document.getElementById(`brick-${index1}`);
            const brick2 = document.getElementById(`brick-${index2}`);
            if (brick1) brick1.classList.remove(className);
            if (brick2) brick2.classList.remove(className);
        }

        function animateSwap(index1, index2, callback) {
            const brick1 = document.getElementById(`brick-${index1}`);
            const brick2 = document.getElementById(`brick-${index2}`);

            if (!brick1 || !brick2) {
                if (callback) callback();
                return;
            }

            brick1.classList.add('swapping');
            brick2.classList.add('swapping');

            currentTimeout = setTimeout(() => {
                if (isPlaying === false && playBtn.textContent === 'Play') {
                    brick1.classList.remove('swapping');
                    brick2.classList.remove('swapping');
                    if (callback) callback(); 
                    return; 
                }
                
                const parent = brick1.parentNode;
                const nextSibling1 = brick1.nextSibling;
                
                if (nextSibling1 === brick2) {
                    parent.insertBefore(brick2, brick1);
                } else {
                    const nextSibling2 = brick2.nextSibling;
                    parent.insertBefore(brick1, nextSibling2);
                    parent.insertBefore(brick2, nextSibling1);
                }
                
                brick1.id = `brick-${index2}`;
                brick2.id = `brick-${index1}`;
                
                currentTimeout = setTimeout(() => {
                    if (isPlaying === false && playBtn.textContent === 'Play') {
                        if (callback) callback(); 
                        return; 
                    }
                    
                    brick1.classList.remove('swapping');
                    brick2.classList.remove('swapping');
                    
                    arrayInput.value = array.join(', ');

                    if (callback) callback();
                }, ANIMATION_DELAY);
            }, ANIMATION_DELAY);
        }
        
        function play() {
            isPlaying = true;
            playBtn.textContent = 'Pause';
            playBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
            playBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600');
            
            disableControls(true); 
            
            playInterval = setInterval(() => {
                if (currentTimeout) return; 
                
                if (sortCompleted) {
                    pause(true); 
                } else {
                    step(); 
                }
            }, PLAY_INTERVAL_DELAY);
        }

        function pause(isResetOrComplete = false) {
            isPlaying = false;
            clearInterval(playInterval); 
            clearTimeout(currentTimeout); 
            currentTimeout = null; 
            
            drawBricks(array);
            
            visualisationArea.querySelectorAll('.brick').forEach(brick => {
                brick.classList.remove('comparing', 'swapping', 'sorted');
            });
            for (let k = (elementCount - 1 - i); k < elementCount; k++) { 
                 const brick = document.getElementById(`brick-${k}`);
                 if (brick) brick.classList.add('sorted');
            }
            
            if (isSorting && !sortCompleted) {
                highlight(j, j + 1, 'comparing');
            }
            
            if (!isResetOrComplete) {
                enableControls();
                updateStatus(`Paused. Iteration ${i + 1}. Ready to continue comparing ${array[j]} and ${array[j+1]}.`);
            }

            playBtn.textContent = 'Play';
            playBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
            playBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
        }

    </script>
</body>
</html>

