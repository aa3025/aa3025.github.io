<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draggable Numbers</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            height: 100vh;
            margin: 0;
            overflow-x: hidden; /* Only allow vertical scroll if content is long */
        }
        .drag-container {
            position: relative;
            width: 100%;
            min-height: 100vh;
            padding-top: 130px; /* Increased space for the taller header */
            padding-bottom: 200px; /* Space for fixed output */
        }
        .number-circle {
            position: absolute;
            width: 50px;
            height: 50px;
            cursor: grab;
            transition: box-shadow 0.1s ease, transform 0.2s ease, left 0.3s ease-in-out, top 0.3s ease-in-out; /* Added transition for smooth swapping */
            user-select: none;
            z-index: 10;
        }
        .number-circle:active {
            cursor: grabbing;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
            z-index: 50;
            transform: scale(1.1); /* Slight lift on active */
        }
        /* Style for the Xmin drop target */
        #xminPanel {
            transition: background-color 0.2s;
        }
        /* Highlight Xmin panel when a draggable element is over it */
        #xminPanel.drag-over {
            background-color: #e0f2fe; /* Light blue */
            border-color: #3b82f6;
        }
    </style>
</head>
<body>

<div class="drag-container" id="dragContainer">
    <!-- Fixed header remains at the top -->
    <div class="fixed top-0 left-0 right-0 p-4 bg-white shadow-lg text-center z-40">
        <h1 class="text-xl font-bold text-gray-800"><span id="headerN"></span> Interactive Selection Sort</h1>
        <p class="text-sm text-gray-500">Drag numbers onto the Xmin Tracker to find the smallest element, or drag circles onto each other to **swap** their positions.</p>

        <!-- N Control Panel -->
        <div class="mt-2 flex justify-center items-center space-x-3">
            <label for="nInput" class="text-sm font-semibold text-gray-700">List Size (N):</label>
            <input 
                type="number" 
                id="nInput" 
                min="1" 
                max="50" 
                value="25"
                class="w-20 p-1 border border-gray-300 rounded-md text-center text-sm"
            >
            <button 
                onclick="regenerateCircles(parseInt(document.getElementById('nInput').value));"
                class="bg-blue-500 hover:bg-blue-600 text-white text-sm font-medium py-1 px-3 rounded-md transition duration-150 shadow-sm"
            >
                Regenerate
            </button>
        </div>
    </div>

    <!-- Xmin Control Panel -->
    <div 
        id="xminPanel" 
        class="fixed top-[140px] right-4 w-64 p-4 bg-white rounded-xl shadow-2xl border-4 border-blue-500/20 z-40"
        ondragover="event.preventDefault(); this.classList.add('drag-over');"
        ondragleave="this.classList.remove('drag-over');"
        ondrop="handleDropXmin(event); this.classList.remove('drag-over');"
    >
        <h3 class="text-xl font-extrabold text-blue-700 mb-2 border-b-2 pb-2 border-blue-100">Xmin Tracker</h3>
        <p class="text-sm text-gray-600 mb-4 font-semibold">
            Current Smallest Value Found (Xmin):
        </p>
        
        <div class="text-center mb-4">
            <span id="xminDisplay" class="p-3 border-2 border-blue-300 rounded-lg inline-block w-full text-5xl font-mono font-bold text-blue-800 shadow-inner bg-blue-50">1000</span>
        </div>

        <p class="text-xs text-gray-500 mt-2">
            Drag a number here to compare. Xmin updates only if the dragged value is smaller.
        </p>

        <button 
            id="selectMinButton"
            onclick="selectMinimum();" 
            class="mt-4 w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3 rounded-lg transition duration-150 shadow-md transform hover:scale-[1.01]"
        >
            Select & Move Minimum
        </button>
    </div>
    
    <!-- Circles will be placed in a grid below the header -->
</div>

<!-- Fixed Sorted Output Panel at the bottom -->
<div class="fixed bottom-0 left-0 right-0 p-4 bg-gray-800 shadow-2xl z-40">
    <h3 class="text-lg font-bold text-white mb-2">Sorted Output List:</h3>
    <div id="sortedOutput" class="flex flex-wrap gap-2 min-h-[50px] p-2 bg-gray-900 rounded-lg border border-gray-700">
        <p class="text-gray-400 italic text-sm" id="outputPlaceholder">Drag numbers here by finalizing Xmin...</p>
    </div>
</div>

<script>
    // The full original list of 50 numbers
    const FULL_NUMBERS_LIST = [
        69, 55, 66, 89, 52, 81, 58, 23, 71, 10, 38, 12, 82, 41, 83, 100,
        99, 22, 86, 5, 93, 37, 40, 21, 29, 76, 4, 48, 16, 74, 88, 47, 92,
        24, 35, 25, 80, 56, 49, 2, 30, 13, 17, 65, 34, 45, 91, 53, 63, 36
    ];

    const container = document.getElementById('dragContainer');
    const xminDisplay = document.getElementById('xminDisplay');
    const sortedOutput = document.getElementById('sortedOutput');
    const outputPlaceholder = document.getElementById('outputPlaceholder');
    const nInput = document.getElementById('nInput');
    const headerN = document.getElementById('headerN');

    const elementSize = 50; // Width and height of the circle
    let currentN = 25; // Default list size
    let currentXminValue = 1000;
    let minElementId = null;

    // --- Initialization & Regeneration ---

    /**
     * Clears all circles and sorted output, resets Xmin, and re-initializes the grid.
     * @param {number} n - The new number of elements to display.
     */
    function regenerateCircles(n) {
        // Validation: Clamp N between 1 and 50
        n = Math.max(1, Math.min(FULL_NUMBERS_LIST.length, n));
        nInput.value = n; // Update input field if clamping occurred
        currentN = n;

        // Reset display elements
        currentXminValue = 1000;
        minElementId = null;
        xminDisplay.textContent = currentXminValue;
        sortedOutput.innerHTML = '<p class="text-gray-400 italic text-sm" id="outputPlaceholder">Drag numbers here by finalizing Xmin...</p>';
        
        // Ensure the placeholder is visible if the list is empty
        const ph = document.getElementById('outputPlaceholder');
        if (ph) ph.style.display = 'block';

        headerN.textContent = `Interactive Selection Sort (N=${currentN})`;
        
        // Clear existing circles
        container.querySelectorAll('.number-circle').forEach(c => c.remove());
        
        // Re-initialize
        initializeCircles();
    }
    
    /**
     * Gets the current subset of numbers based on currentN.
     */
    function getNumbersList() {
        return FULL_NUMBERS_LIST.slice(0, currentN);
    }

    /**
     * Initializes the circles and places them in a dynamic grid at the top.
     */
    function initializeCircles() {
        const numbers = getNumbersList();
        
        // Calculate number of columns for a square-ish layout
        const N_COLS = Math.ceil(Math.sqrt(currentN)); 
        const SPACING = 20;
        const GRID_START_Y = 130; // Start below the fixed header

        numbers.forEach((number, i) => {
            const circle = document.createElement('div');
            
            // Generate a unique ID for tracking
            const elementId = `num-${number}-${i}`;
            
            // Apply Tailwind classes for styling
            circle.className = 'number-circle flex items-center justify-center rounded-full text-white text-sm font-semibold shadow-lg transition duration-150 ease-in-out hover:shadow-xl';

            // Color logic
            let bgColor;
            if (number <= 25) bgColor = 'bg-red-500';
            else if (number <= 50) bgColor = 'bg-yellow-500';
            else if (number <= 75) bgColor = 'bg-blue-500';
            else bgColor = 'bg-green-500';

            circle.classList.add(bgColor);
            circle.textContent = number;
            circle.id = elementId;
            circle.setAttribute('data-value', number);
            circle.setAttribute('draggable', true); // Make the circles draggable

            // --- Grid Positioning Logic ---
            const col = i % N_COLS;
            const row = Math.floor(i / N_COLS);

            // Left Margin applied to center the grid roughly (simple approach)
            const leftMargin = (container.clientWidth / 2) - (N_COLS * (elementSize + SPACING) / 2);
            
            const initialX = col * (elementSize + SPACING) + SPACING + (leftMargin > 0 ? leftMargin : 0);
            const initialY = row * (elementSize + SPACING) + GRID_START_Y;
            
            circle.style.left = `${initialX}px`;
            circle.style.top = `${initialY}px`;

            // Drag event listeners for data transfer
            circle.addEventListener('dragstart', dragStart);
            
            // NEW: Add dragover/drop listeners to enable circle-to-circle swapping
            circle.addEventListener('dragover', (e) => { 
                e.preventDefault();
                // Add a visual highlight for the target circle
                e.currentTarget.classList.add('ring-4', 'ring-purple-500', 'ring-offset-2');
            });
            circle.addEventListener('dragleave', (e) => {
                // Remove visual highlight
                e.currentTarget.classList.remove('ring-4', 'ring-purple-500', 'ring-offset-2');
            });
            circle.addEventListener('drop', handleCircleDrop);
            
            container.appendChild(circle);
        });
    }
    
    // --- Drag and Drop Handlers ---

    /**
     * Handles the start of a drag operation, setting the data to be transferred.
     * @param {DragEvent} e 
     */
    function dragStart(e) {
        // Transfer the element's ID and value (value is needed for Xmin panel)
        e.dataTransfer.setData('text/plain', JSON.stringify({
            id: e.target.id,
            value: parseInt(e.target.getAttribute('data-value'))
        }));
    }

    /**
     * Handles the drop operation onto the Xmin tracker panel.
     * @param {DragEvent} e 
     */
    function handleDropXmin(e) {
        e.preventDefault();
        
        try {
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            const droppedValue = data.value;
            const droppedId = data.id;

            // Only consider circles that haven't been sorted yet
            if (!document.getElementById(droppedId)) {
                // Ignore drop if the element is already removed/sorted
                return;
            }

            if (droppedValue < currentXminValue) {
                // New minimum found! Update Xmin and highlight the circle
                currentXminValue = droppedValue;
                minElementId = droppedId;
                xminDisplay.textContent = droppedValue;

                // Highlight the new minimum circle (remove all other pink rings first)
                document.querySelectorAll('.number-circle').forEach(el => {
                    el.classList.remove('ring-4', 'ring-pink-500', 'ring-offset-2');
                });
                const minEl = document.getElementById(minElementId);
                if (minEl) {
                    minEl.classList.add('ring-4', 'ring-pink-500', 'ring-offset-2');
                }
            }
        } catch (error) {
            console.error("Error processing dropped data:", error);
        }
    }

    /**
     * Swaps the position of the dragged element with the drop target element.
     * @param {DragEvent} e 
     */
    function handleCircleDrop(e) {
        e.preventDefault();
        // Remove the visual highlight from the target circle
        e.currentTarget.classList.remove('ring-4', 'ring-purple-500', 'ring-offset-2'); 

        const targetEl = e.currentTarget; // The circle being dropped ONTO

        try {
            const draggedData = JSON.parse(e.dataTransfer.getData('text/plain'));
            const draggedEl = document.getElementById(draggedData.id); // The circle being dragged

            // Prevent dropping on self or if the dragged element is already sorted
            if (!draggedEl || draggedEl.id === targetEl.id) {
                return;
            }

            // Get target positions
            const targetX = targetEl.style.left;
            const targetY = targetEl.style.top;
            
            // Get dragged element's current positions
            const draggedX = draggedEl.style.left;
            const draggedY = draggedEl.style.top;

            // 1. Target moves to dragged's original spot
            targetEl.style.left = draggedX;
            targetEl.style.top = draggedY;

            // 2. Dragged moves to target's original spot (creates a smooth visual swap)
            draggedEl.style.left = targetX;
            draggedEl.style.top = targetY;

        } catch (error) {
            console.error("Error processing circle drop:", error);
        }
    }

    // --- Algorithm Step Execution ---

    /**
     * Finalizes the current pass by moving the minimum element to the sorted output.
     */
    function selectMinimum() {
        if (currentXminValue === 1000) {
            console.warn("No minimum selected yet. Please drag circles onto the Xmin Tracker.");
            return;
        }

        const minEl = document.getElementById(minElementId);

        if (minEl) {
            // 1. Remove from the drag container
            minEl.remove();

            // 2. Create the final sorted element clone
            const sortedItem = document.createElement('div');
            sortedItem.className = 'flex items-center justify-center rounded-md text-white text-sm font-semibold p-2 shadow-md';
            
            // Re-use color class (simple check for the class that starts with 'bg-')
            const bgColorClass = Array.from(minEl.classList).find(cls => cls.startsWith('bg-'));
            if (bgColorClass) {
                sortedItem.classList.add(bgColorClass); 
            }

            sortedItem.textContent = currentXminValue;

            // 3. Add to the sorted output area
            // Check for and remove placeholder before adding the first item
            const currentPlaceholder = document.getElementById('outputPlaceholder');
            if (currentPlaceholder) {
                currentPlaceholder.remove();
            }
            sortedOutput.appendChild(sortedItem);
        }
        
        // 4. Reset for the next pass
        currentXminValue = 1000;
        minElementId = null;
        xminDisplay.textContent = currentXminValue;
        
        // Remove highlights from any remaining circles
        document.querySelectorAll('.number-circle').forEach(el => {
            el.classList.remove('ring-4', 'ring-pink-500', 'ring-offset-2');
        });
        
        console.log(`Pass complete. Minimum value ${currentXminValue} moved to sorted list.`);
    }


    // --- General Setup ---
    window.addEventListener('load', () => {
        // Initialize with default N=25 on load
        regenerateCircles(currentN);
    });
    
    // Simple resize logic: just re-initialize the circles
    window.addEventListener('resize', () => {
        // Re-initialize with the current N value to adjust layout
        regenerateCircles(currentN);
    });

</script>

</body>
</html>
