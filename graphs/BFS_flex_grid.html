<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BFS Grid Visualization (8-Directional)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the visualization */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Make canvas visually responsive but maintain aspect ratio */
        canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
            border: 2px solid #E5E7EB; /* gray-200 */
            border-radius: 0.5rem; /* rounded-lg */
            background-color: #FFFFFF;
        }
        /* Style for the select dropdown */
        select, input[type="number"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        select {
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
        }
        /* Hide spinner buttons on number input */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
             padding-right: 0.75rem; /* 12px */
        }
    </style>
</head>
<body class="bg-white min-h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-6xl bg-white rounded-lg p-6"> <!-- Increased max-width -->
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">
            BFS Grid Visualization (8-Directional)
        </h1>
        
        <!-- Main container - Horizontal layout on large screens -->
        <div class="flex flex-col lg:flex-row gap-6">
            
            <!-- Visualization Area (Canvas) - Takes 60% width -->
            <div class="flex-grow w-full lg:w-3/5">
                <canvas id="bfs-canvas"></canvas> <!-- Size set by JS -->
            </div>
            
            <!-- Controls and Info Panel - Takes 40% width -->
            <div class="w-full lg:w-2/5 flex-shrink-0 space-y-4">
                
                <!-- Control Buttons -->
                <div>
                    <h2 class="text-xl font-semibold text-gray-700 mb-2">Controls</h2>
                    <!-- Auto-play controls -->
                    <div class="flex space-x-2 mb-2">
                        <button id="start-btn" class="w-full bg-green-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-200">
                            Auto-Play
                        </button>
                        <button id="pause-btn" class="w-full bg-yellow-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-yellow-600 transition duration-200 disabled:opacity-50" disabled>
                            Pause
                        </button>
                    </div>
                     <!-- Manual controls -->
                    <div class="flex space-x-2 mb-2">
                        <button id="prev-btn" class="w-full bg-white text-gray-700 border border-gray-300 font-semibold py-2 px-4 rounded-lg hover:bg-gray-50 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            Previous
                        </button>
                        <button id="next-btn" class="w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            Next
                        </button>
                        <button id="reset-btn" class="w-1/2 bg-white text-red-700 border border-red-400 font-semibold py-2 px-4 rounded-lg hover:bg-red-50 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            Reset
                        </button>
                    </div>
                    <!-- Settings -->
                    <div class="grid grid-cols-1 gap-2">
                        <!-- Grid Size Input -->
                        <div>
                            <label for="grid-size-input" class="block text-sm font-medium text-gray-700 mb-1">Grid Size (odd)</label>
                            <input type="number" id="grid-size-input" value="21" min="3" max="51" step="2" class="w-full bg-white border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5">
                        </div>
                    </div>
                </div>

                <!-- Step Description -->
                <div>
                    <h2 class="text-xl font-semibold text-gray-700 mb-1">Step Description</h2>
                    <div class="min-h-[50px] bg-white border border-gray-300 rounded-lg p-3">
                        <p id="step-description" class="text-lg text-gray-800">Algorithm ready. Click 'Next' or 'Auto-Play'.</p>
                    </div>
                </div>

                <!-- Info Panels -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Stats -->
                    <div>
                        <h2 class="text-xl font-semibold text-gray-700 mb-1">Stats</h2>
                        <div class="bg-white border border-gray-300 rounded-lg p-3 space-y-2">
                            <p class="text-gray-700">Queue Size: <span id="queue-size" class="font-mono font-bold text-blue-600">0</span></p>
                            <p class="text-gray-700">Visited Count: <span id="visited-count" class="font-mono font-bold text-green-600">0</span></p>
                        </div>
                    </div>
                    
                    <!-- Legend -->
                    <div>
                        <h2 class="text-xl font-semibold text-gray-700 mb-2">Legend</h2>
                        <div class="space-y-2">
                            <div class="flex items-center">
                                <!-- Updated high-contrast colors -->
                                <div class="w-5 h-5 rounded-full mr-2 border border-gray-700" style="background-color: #E5E7EB"></div>
                                <span>Unvisited Node</span>
                            </div>
                            <div class="flex items-center">
                                <div class="w-5 h-5 rounded-full mr-2 border border-gray-700" style="background-color: #3B82F6"></div>
                                <span>In Queue</span>
                            </div>
                            <div class="flex items-center">
                                <div class="w-5 h-5 rounded-full mr-2 border border-gray-700" style="background-color: #10B981"></div>
                                <span>Visited</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- Constants ---
            let PADDING = 32; // Padding around the grid
            let NODE_RADIUS = 6; // Radius of the node dot
            
            // --- DOM Elements ---
            const canvas = document.getElementById('bfs-canvas');
            const ctx = canvas.getContext('2d');
            
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const resetBtn = document.getElementById('reset-btn');
            const startBtn = document.getElementById('start-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const gridSizeInput = document.getElementById('grid-size-input');
            
            const stepDescription = document.getElementById('step-description');
            const queueSizeEl = document.getElementById('queue-size');
            const visitedCountEl = document.getElementById('visited-count');
            
            const COLORS = {
                // High contrast colors
                default: '#E5E7EB',   // gray-200 (unvisited node)
                inQueue: '#3B82F6', // blue-500 (in queue)
                visited: '#10B981', // emerald-500 (visited)
                edge: '#D1D5DB',      // gray-300 (horizontal/vertical edges)
                diagEdge: '#E5E7EB',  // gray-200 (diagonal edges)
                nodeBorder: '#374151' // gray-700
            };

            // --- State (Dynamic) ---
            let GRID_SIZE = 21;
            let START_NODE = { x: 10, y: 10 };
            let CANVAS_WIDTH = 704;
            let CANVAS_HEIGHT = 704;
            let CELL_SPACING = 32;

            let steps = [];
            let currentStep = 0;
            let isPlaying = false;
            let timeoutId = null;

            // --- Utility Functions ---

            function createGrid(size, value) {
                return Array.from({ length: size }, () => Array(size).fill(value));
            }

            function deepCopyGrid(grid) {
                return grid.map(row => [...row]);
            }
            
            function getCanvasCoords(x, y) {
                return {
                    x: PADDING + x * CELL_SPACING,
                    y: PADDING + y * CELL_SPACING
                };
            }

            const nodeToKey = (node) => `${node.x},${node.y}`;

            /** * Gets valid neighbors for a given cell (8-directional).
             */
            function getNeighbors(x, y) {
                const neighbors = [];
                // 8 directions: 4 cardinal, 4 diagonal
                const directions = [
                    [0, 1], [0, -1], [1, 0], [-1, 0], // Cardinal
                    [1, 1], [1, -1], [-1, 1], [-1, -1] // Diagonal
                ]; 
                
                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                        neighbors.push({ x: newX, y: newY });
                    }
                }
                return neighbors;
            }

            // --- Drawing Function ---

            function drawGrid(gridStates) {
                // Set canvas size (might have changed)
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // 1. Draw Diagonal Edges (Lighter)
                ctx.lineWidth = 1;
                ctx.strokeStyle = COLORS.diagEdge;
                for (let y = 0; y < GRID_SIZE - 1; y++) {
                    for (let x = 0; x < GRID_SIZE - 1; x++) {
                        const p1 = getCanvasCoords(x, y);
                        const p2 = getCanvasCoords(x + 1, y + 1);
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                        
                        const p3 = getCanvasCoords(x + 1, y);
                        const p4 = getCanvasCoords(x, y + 1);
                        ctx.beginPath();
                        ctx.moveTo(p3.x, p3.y);
                        ctx.lineTo(p4.x, p4.y);
                        ctx.stroke();
                    }
                }

                // 2. Draw Horizontal/Vertical Edges (Darker)
                ctx.lineWidth = 2;
                ctx.strokeStyle = COLORS.edge;
                for (let i = 0; i < GRID_SIZE; i++) {
                    // Horizontal lines
                    const p1_h = getCanvasCoords(0, i);
                    const p2_h = getCanvasCoords(GRID_SIZE - 1, i);
                    ctx.beginPath();
                    ctx.moveTo(p1_h.x, p1_h.y);
                    ctx.lineTo(p2_h.x, p2_h.y);
                    ctx.stroke();
                    
                    // Vertical lines
                    const p1_v = getCanvasCoords(i, 0);
                    const p2_v = getCanvasCoords(i, GRID_SIZE - 1);
                    ctx.beginPath();
                    ctx.moveTo(p1_v.x, p1_v.y);
                    ctx.lineTo(p2_v.x, p2_v.y);
                    ctx.stroke();
                }
                
                // 3. Draw Nodes (Dots) on top
                ctx.lineWidth = 1;
                ctx.strokeStyle = COLORS.nodeBorder;
                
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const state = gridStates[y][x];
                        const p = getCanvasCoords(x, y);
                        
                        ctx.fillStyle = COLORS[state];
                        
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, NODE_RADIUS, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke(); // Draw border
                    }
                }
            }

            // --- Algorithm Step Generation (BFS) ---

            function generateBFSSteps() {
                steps = [];
                // Now uses global GRID_SIZE
                let gridStates = createGrid(GRID_SIZE, 'default');
                let queue = [];
                let visited = createGrid(GRID_SIZE, false);
                let visitedCount = 0;

                // Step 0: Initial state
                steps.push({
                    states: deepCopyGrid(gridStates),
                    queueSize: 0,
                    visitedCount: 0,
                    message: "Algorithm ready. Click 'Next' or 'Auto-Play'."
                });

                // Step 1: Add start node (uses global START_NODE)
                queue.push(START_NODE);
                visited[START_NODE.y][START_NODE.x] = true;
                gridStates[START_NODE.y][START_NODE.x] = 'inQueue';
                
                steps.push({
                    states: deepCopyGrid(gridStates),
                    queueSize: queue.length,
                    visitedCount: 0,
                    message: `Enqueue start node (${START_NODE.x}, ${START_NODE.y}).`
                });

                // Main BFS loop
                while (queue.length > 0) {
                    const currentNode = queue.shift();
                    const { x, y } = currentNode;

                    // Visit node
                    gridStates[y][x] = 'visited';
                    visitedCount++;
                    
                    let neighborsAdded = 0;
                    
                    // Get all neighbors (8-directional)
                    const neighbors = getNeighbors(x, y);
                    for (const neighbor of neighbors) {
                        if (!visited[neighbor.y][neighbor.x]) {
                            visited[neighbor.y][neighbor.x] = true;
                            gridStates[neighbor.y][neighbor.x] = 'inQueue';
                            queue.push(neighbor);
                            neighborsAdded++;
                        }
                    }
                    
                    // Add a step for this visit and all its enqueues
                    steps.push({
                        states: deepCopyGrid(gridStates),
                        queueSize: queue.length,
                        visitedCount: visitedCount,
                        message: `Visit (${x},${y}), enqueue ${neighborsAdded} unvisited neighbors.`
                    });
                }
                
                // Final step
                steps.push({
                    states: deepCopyGrid(gridStates),
                    queueSize: 0,
                    visitedCount: visitedCount,
                    message: "Traversal complete. Queue is empty."
                });
            }

            // --- Step Rendering and Navigation ---

            function renderStep(index) {
                if (index < 0 || index >= steps.length) return;

                currentStep = index;
                const step = steps[currentStep];

                // Update canvas
                drawGrid(step.states);

                // Update UI panels
                stepDescription.textContent = step.message;
                queueSizeEl.textContent = step.queueSize;
                visitedCountEl.textContent = step.visitedCount;

                // Update button states
                prevBtn.disabled = (currentStep === 0);
                nextBtn.disabled = (currentStep === steps.length - 1);
                resetBtn.disabled = (currentStep === 0);
                
                if (currentStep === steps.length - 1) {
                    startBtn.disabled = true;
                } else if (!isPlaying) {
                    startBtn.disabled = false;
                }
            }

            function handleNext() {
                if (currentStep < steps.length - 1) {
                    renderStep(currentStep + 1);
                }
            }

            function handlePrev() {
                if (currentStep > 0) {
                    renderStep(currentStep - 1);
                }
            }
            
            function handleReset() {
                handlePause();
                
                // Read new grid size
                let newSize = parseInt(gridSizeInput.value, 10);
                // Validate: must be odd, between 3 and 51
                if (isNaN(newSize) || newSize < 3 || newSize > 51) {
                    newSize = 21; // Reset to default
                    gridSizeInput.value = "21";
                } else if (newSize % 2 === 0) {
                    newSize++; // Force to next odd number
                    if (newSize > 51) newSize = 51;
                    gridSizeInput.value = newSize.toString();
                }
                GRID_SIZE = newSize;
                
                // --- Dynamic Size Calculation ---
                const canvasContainer = canvas.parentElement;
                if (!canvasContainer) {
                    console.error("Canvas container not found!");
                    return;
                }
                const containerWidth = canvasContainer.clientWidth || 300;
                const availableWidth = containerWidth - PADDING * 2;
                
                CELL_SPACING = Math.floor(availableWidth / (GRID_SIZE - 1));
                if (CELL_SPACING < 4) CELL_SPACING = 4;
                
                NODE_RADIUS = Math.max(2, Math.floor(CELL_SPACING / 3));
                if (NODE_RADIUS > 8) NODE_RADIUS = 8;
                
                START_NODE = { x: Math.floor(GRID_SIZE / 2), y: Math.floor(GRID_SIZE / 2) };
                CANVAS_WIDTH = (GRID_SIZE - 1) * CELL_SPACING + PADDING * 2;
                CANVAS_HEIGHT = CANVAS_WIDTH;
                // --- End Dynamic Size Calculation ---
                
                currentStep = 0;
                generateBFSSteps(); // Re-generate steps
                renderStep(0);
                startBtn.disabled = false;
            }

            function handleStart() {
                if (isPlaying) return;
                isPlaying = true;
                startBtn.disabled = true;
                pauseBtn.disabled = false;
                
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                resetBtn.disabled = true;
                gridSizeInput.disabled = true; // Disable controls while playing

                autoPlayLoop();
            }

            function handlePause() {
                isPlaying = false;
                if (timeoutId) clearTimeout(timeoutId);
                timeoutId = null;
                
                pauseBtn.disabled = true;
                gridSizeInput.disabled = false; // Re-enable controls
                // Re-enable manual controls
                renderStep(currentStep);
            }

            function autoPlayLoop() {
                if (!isPlaying) {
                    return;
                }
                
                if (currentStep >= steps.length - 1) {
                    handlePause();
                    renderStep(steps.length - 1);
                    return;
                }

                handleNext();
                
                timeoutId = setTimeout(autoPlayLoop, 100); // 100ms per step
            }

            // --- Event Listeners ---
            prevBtn.addEventListener('click', handlePrev);
            nextBtn.addEventListener('click', handleNext);
            resetBtn.addEventListener('click', handleReset);
            startBtn.addEventListener('click', handleStart);
            pauseBtn.addEventListener('click', handlePause);
            gridSizeInput.addEventListener('change', handleReset); // Reset on change
            
            // --- Initial Setup ---
            const observer = new ResizeObserver(entries => {
                if (entries[0].contentRect.width > 0) {
                     handleReset();
                }
            });
            if (canvas.parentElement) {
                observer.observe(canvas.parentElement);
            }
            
            handleReset(); // Initialize
            
            let resizeTimer;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(handleReset, 150);
            });

        });
    </script>

</body>
</html>