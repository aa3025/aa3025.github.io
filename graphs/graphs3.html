<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editable Random Graph Generator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .controls {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        input[type="number"] {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 80px;
        }
        button {
            background-color: #4a6ee0;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #3a5ec9;
        }
        .graph-container {
            position: relative;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            height: 600px;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .matrix-container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
        }
        table {
            border-collapse: collapse;
            margin: 0 auto;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: center;
        }
        th {
            background-color: #f2f2f2;
        }
        .matrix-cell {
            width: 30px;
            height: 30px;
            text-align: center;
            border: none;
            background-color: transparent;
            font-weight: bold;
            cursor: pointer;
        }
        .matrix-cell:hover {
            background-color: #f0f0f0;
        }
        .matrix-cell.connected {
            background-color: #4a6ee0;
            color: white;
        }
        .instructions {
            background-color: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }
        .instructions h3 {
            margin-top: 0;
            color: #2c5aa0;
        }
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Editable Random Graph Generator</h1>
        
        <div class="controls">
            <div class="input-group">
                <label for="nodeCount">Number of nodes:</label>
                <input type="number" id="nodeCount" min="1" max="26" value="8">
                <button id="generateBtn">Generate Graph</button>
            </div>
            <div class="instructions">
                <h3>Instructions:</h3>
                <p>Enter the number of nodes (1-26) and click "Generate Graph". The nodes will be labeled with capital letters A-Z. You can:</p>
                <ul>
                    <li>Drag nodes around to rearrange the graph</li>
                    <li>Click on matrix cells to toggle connections between nodes</li>
                    <li>The graph updates automatically when you modify the matrix</li>
                </ul>
            </div>
        </div>
        
        <div class="graph-container">
            <canvas id="graphCanvas"></canvas>
        </div>
        
        <div class="matrix-container">
            <h2>Adjacency Matrix (Click cells to toggle connections)</h2>
            <div id="matrixDisplay"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            const nodeCountInput = document.getElementById('nodeCount');
            const generateBtn = document.getElementById('generateBtn');
            const matrixDisplay = document.getElementById('matrixDisplay');
            
            // Set canvas dimensions
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            let nodes = [];
            let adjacencyMatrix = [];
            let selectedNode = null;
            let offsetX, offsetY;
            
            // Generate random color
            function getRandomColor() {
                const hue = Math.floor(Math.random() * 360);
                return `hsl(${hue}, 70%, 60%)`;
            }
            
            // Generate random adjacency matrix
            function generateAdjacencyMatrix(n) {
                const matrix = [];
                for (let i = 0; i < n; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < n; j++) {
                        // 30% chance of connection (avoid too dense graphs)
                        matrix[i][j] = Math.random() < 0.3 ? 1 : 0;
                    }
                }
                return matrix;
            }
            
            // Create nodes with random positions
            function createNodes(n) {
                const newNodes = [];
                const radius = 30;
                const margin = 50;
                
                for (let i = 0; i < n; i++) {
                    // Try to find a position that doesn't overlap too much
                    let x, y, attempts = 0;
                    do {
                        x = margin + Math.random() * (canvas.width - 2 * margin);
                        y = margin + Math.random() * (canvas.height - 2 * margin);
                        attempts++;
                    } while (isOverlapping(newNodes, x, y, radius * 2) && attempts < 100);
                    
                    newNodes.push({
                        id: i,
                        label: String.fromCharCode(65 + i), // A, B, C, ...
                        x: x,
                        y: y,
                        radius: radius,
                        color: getRandomColor(),
                        textColor: '#FFFFFF'
                    });
                }
                
                return newNodes;
            }
            
            // Check if a new node would overlap with existing nodes
            function isOverlapping(nodes, x, y, minDistance) {
                for (const node of nodes) {
                    const dx = node.x - x;
                    const dy = node.y - y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < minDistance) {
                        return true;
                    }
                }
                return false;
            }
            
            // Draw the graph
            function drawGraph() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw edges
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 2;
                
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (adjacencyMatrix[i][j] === 1) {
                            ctx.beginPath();
                            ctx.moveTo(nodes[i].x, nodes[i].y);
                            ctx.lineTo(nodes[j].x, nodes[j].y);
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw nodes
                for (const node of nodes) {
                    // Draw node circle
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                    ctx.fillStyle = node.color;
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw node label
                    ctx.fillStyle = node.textColor;
                    ctx.font = 'bold 18px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.label, node.x, node.y);
                }
            }
            
            // Display adjacency matrix as HTML table with editable cells
            function displayMatrix(matrix) {
                let html = '<table>';
                
                // Header row
                html += '<tr><th></th>';
                for (let i = 0; i < matrix.length; i++) {
                    html += `<th>${String.fromCharCode(65 + i)}</th>`;
                }
                html += '</tr>';
                
                // Data rows
                for (let i = 0; i < matrix.length; i++) {
                    html += `<tr><th>${String.fromCharCode(65 + i)}</th>`;
                    for (let j = 0; j < matrix[i].length; j++) {
                        const cellValue = matrix[i][j];
                        const cellClass = cellValue === 1 ? 'matrix-cell connected' : 'matrix-cell';
                        // Disable self-connections (diagonal)
                        if (i === j) {
                            html += `<td><input type="text" class="matrix-cell" value="0" readonly></td>`;
                        } else {
                            html += `<td><input type="text" class="${cellClass}" value="${cellValue}" data-row="${i}" data-col="${j}"></td>`;
                        }
                    }
                    html += '</tr>';
                }
                
                html += '</table>';
                matrixDisplay.innerHTML = html;
                
                // Add event listeners to matrix cells
                const matrixCells = document.querySelectorAll('.matrix-cell:not([readonly])');
                matrixCells.forEach(cell => {
                    cell.addEventListener('click', function() {
                        const row = parseInt(this.getAttribute('data-row'));
                        const col = parseInt(this.getAttribute('data-col'));
                        
                        // Toggle the connection
                        adjacencyMatrix[row][col] = adjacencyMatrix[row][col] === 1 ? 0 : 1;
                        adjacencyMatrix[col][row] = adjacencyMatrix[row][col]; // Keep symmetric
                        
                        // Update the matrix display
                        displayMatrix(adjacencyMatrix);
                        
                        // Redraw the graph
                        drawGraph();
                    });
                });
            }
            
            // Find node at coordinates
            function getNodeAt(x, y) {
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const node = nodes[i];
                    const dx = node.x - x;
                    const dy = node.y - y;
                    if (dx * dx + dy * dy <= node.radius * node.radius) {
                        return node;
                    }
                }
                return null;
            }
            
            // Mouse event handlers
            canvas.addEventListener('mousedown', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                selectedNode = getNodeAt(x, y);
                if (selectedNode) {
                    offsetX = x - selectedNode.x;
                    offsetY = y - selectedNode.y;
                }
            });
            
            canvas.addEventListener('mousemove', function(e) {
                if (selectedNode) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    // Update node position
                    selectedNode.x = x - offsetX;
                    selectedNode.y = y - offsetY;
                    
                    // Keep node within canvas bounds
                    selectedNode.x = Math.max(selectedNode.radius, Math.min(canvas.width - selectedNode.radius, selectedNode.x));
                    selectedNode.y = Math.max(selectedNode.radius, Math.min(canvas.height - selectedNode.radius, selectedNode.y));
                    
                    drawGraph();
                }
            });
            
            canvas.addEventListener('mouseup', function() {
                selectedNode = null;
            });
            
            canvas.addEventListener('mouseleave', function() {
                selectedNode = null;
            });
            
            // Generate graph button handler
            generateBtn.addEventListener('click', function() {
                const nodeCount = parseInt(nodeCountInput.value);
                
                if (nodeCount < 1 || nodeCount > 26) {
                    alert('Please enter a number between 1 and 26');
                    return;
                }
                
                // Generate new graph
                adjacencyMatrix = generateAdjacencyMatrix(nodeCount);
                nodes = createNodes(nodeCount);
                
                // Display matrix and draw graph
                displayMatrix(adjacencyMatrix);
                drawGraph();
            });
            
            // Generate initial graph
            generateBtn.click();
        });
    </script>
</body>
</html>