<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Interactive Graph Editor — Curved Edge Fix</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
body {
  font-family: "Inter", sans-serif;
  background-color: #f0f4f8;
  margin: 0;
  overflow: hidden;
}
#canvasContainer {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
#graphCanvas {
  display: block;
  background-color: #ffffff;
}
.node {
  position: absolute;
  width: 40px;
  height: 40px;
  background-color: #3b82f6;
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  cursor: grab;
  user-select: none;
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1),
    0 2px 4px -2px rgba(0, 0, 0, 0.06);
  transition: transform 0.1s ease;
}
.node:active {
  cursor: grabbing;
  z-index: 1000;
  transform: scale(1.1);
}
.node.selected {
  border: 4px solid #10b981;
}
.node.dragging {
  z-index: 1000;
}
#controlPanel {
  max-height: 100%;
  overflow-y: auto;
}
</style>
</head>
<body>
<div id="canvasContainer">
  <canvas id="graphCanvas"></canvas>
  <div id="controlPanel"
    class="absolute top-0 left-0 w-64 p-4 bg-white shadow-2xl rounded-br-xl z-50">
    <h2 class="text-xl font-bold text-gray-800 border-b pb-2 mb-4">
      Graph Editor
    </h2>
    <div class="mb-4">
      <label for="nodeCountInput"
        class="block text-sm font-medium text-gray-700 mb-1"
        >Number of Nodes (A, B, C...):</label
      >
      <div class="flex space-x-2">
        <input type="number" id="nodeCountInput" value="5" min="1" max="26"
          class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" />
        <button onclick="generateNodes()"
          class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg shadow transition">Generate</button>
      </div>
    </div>
    <div class="mb-4 p-3 bg-gray-50 rounded-lg shadow-inner">
      <label class="block text-sm font-medium text-gray-700 mb-2">Graph Type:</label>
      <div class="flex justify-between space-x-2">
        <button id="undirectedBtn" onclick="toggleDirected(false)"
          class="flex-1 py-2 px-3 text-sm font-semibold rounded-lg shadow transition bg-green-500 text-white">Undirected</button>
        <button id="directedBtn" onclick="toggleDirected(true)"
          class="flex-1 py-2 px-3 text-sm font-semibold rounded-lg shadow transition bg-gray-300 text-gray-700 hover:bg-gray-400">Directed</button>
      </div>
    </div>
    <div class="mb-4 p-3 bg-red-50 rounded-lg shadow-inner border-2 border-red-200">
      <label class="block text-sm font-medium text-gray-700 mb-2 font-bold"
        >Connection Tool:</label
      >
      <p class="text-sm text-gray-800 mt-1">
        Right-click a node to <b>SELECT</b> it.
      </p>
      <p class="text-sm text-gray-800 mt-1">
        Right-click a second node to <b>CONNECT</b> them.
      </p>
      <p class="text-sm text-gray-800 mt-1 italic text-red-700">
        (Left-click and drag to move nodes.)
      </p>
      <div id="connectionStatus"
        class="mt-3 p-2 text-center text-white font-semibold rounded-lg bg-red-500">
        Source: None
      </div>
    </div>
    <button onclick="clearAll()"
      class="w-full py-2 px-4 text-sm font-semibold rounded-lg shadow-md transition duration-150 bg-gray-200 text-gray-700 hover:bg-gray-300">
      Clear All Nodes & Edges
    </button>
  </div>
</div>

<script>
const canvas = document.getElementById("graphCanvas");
const ctx = canvas.getContext("2d");
const container = document.getElementById("canvasContainer");
const nodeCountInput = document.getElementById("nodeCountInput");
const connectionStatus = document.getElementById("connectionStatus");
const undirectedBtn = document.getElementById("undirectedBtn");
const directedBtn = document.getElementById("directedBtn");

let nodes = [];
let edges = [];
let isDirected = false;
let selectedNodeId = null;

// ----------- DRAWING -------------

function drawArrowhead(p1x, p1y, cx, cy, p2x, p2y) {
  const headLength = 10;
  const nodeRadius = 20;
  const t = 0.95;
  const t2 = t * t;
  const t1 = 1 - t;
  const t12 = t1 * t1;
  const tx = t12 * p1x + 2 * t1 * t * cx + t2 * p2x;
  const ty = t12 * p1y + 2 * t1 * t * cy + t2 * p2y;
  const angle = Math.atan2(p2y - ty, p2x - tx);
  const arrowX = p2x - nodeRadius * Math.cos(angle);
  const arrowY = p2y - nodeRadius * Math.sin(angle);
  ctx.fillStyle = "#6b7280";
  ctx.beginPath();
  ctx.moveTo(arrowX, arrowY);
  ctx.lineTo(
    arrowX - headLength * Math.cos(angle - Math.PI / 6),
    arrowY - headLength * Math.sin(angle - Math.PI / 6)
  );
  ctx.lineTo(
    arrowX - headLength * Math.cos(angle + Math.PI / 6),
    arrowY - headLength * Math.sin(angle + Math.PI / 6)
  );
  ctx.closePath();
  ctx.fill();
}

function draw() {
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.strokeStyle = "#6b7280";
  ctx.lineWidth = 2;

  for (const edge of edges) {
    const fromNode = nodes.find((n) => n.id === edge.fromId);
    const toNode = nodes.find((n) => n.id === edge.toId);
    if (!fromNode || !toNode) continue;

    const startX = fromNode.x;
    const startY = fromNode.y;
    const endX = toNode.x;
    const endY = toNode.y;

    let ctrlX = (startX + endX) / 2;
    let ctrlY = (startY + endY) / 2;
    const offsetX = endY - startY;
    const offsetY = startX - endX;
    const dist = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
    const normalX = dist ? offsetX / dist : 0;
    const normalY = dist ? offsetY / dist : 0;

    const baseOffsetMagnitude = 40;
    let offsetMultiplier = 0;
   if (edge.groupIndex !== undefined && edge.groupCount !== undefined) {
  // Base offset index, centered around 0
  let base = edge.groupIndex - (edge.groupCount - 1) / 2;
  
  // Alternate offset parity for opposite directions
  if (edge.fromId < edge.toId) {
    offsetMultiplier = base * 2;     // even steps: 0, ±2, ±4...
  } else {
    offsetMultiplier = base * 2 + 1; // odd steps: ±1, ±3, ...
  }
}

    let curveOffset = offsetMultiplier * baseOffsetMagnitude;

    // --- new curvature bias logic ---
    const directionBias =
      ((edge.fromId * 31 + edge.toId * 17) % 10 - 5) / 10; // -0.5..+0.5
    curveOffset += directionBias * 30; // stable fractional curvature

    // optional: enable true random once per edge
    // if (!edge._randomOffset) edge._randomOffset = (Math.random() - 0.5) * 60;
    // curveOffset += edge._randomOffset;

    // flip side for reverse directions
    if (edge.fromId > edge.toId) curveOffset *= -1;
    // --- end curvature bias ---

    ctrlX += normalX * curveOffset;
    ctrlY += normalY * curveOffset;

    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
    ctx.stroke();

    if (isDirected) drawArrowhead(startX, startY, ctrlX, ctrlY, endX, endY);
  }

  requestAnimationFrame(draw);
}

// ----------- NODE MANAGEMENT -------------

function generateNodes() {
  const count = parseInt(nodeCountInput.value);
  clearAll();
  const labels = Array.from({ length: count }, (_, i) =>
    String.fromCharCode(65 + i)
  );
  const minX = 280,
    minY = 50,
    maxX = canvas.width - 50,
    maxY = canvas.height - 50;
  for (let i = 0; i < labels.length; i++) {
    const x = Math.random() * (maxX - minX) + minX;
    const y = Math.random() * (maxY - minY) + minY;
    const el = document.createElement("div");
    el.className = "node";
    el.id = "node-" + (i + 1);
    el.textContent = labels[i];
    el.style.left = x - 20 + "px";
    el.style.top = y - 20 + "px";
    container.appendChild(el);
    nodes.push({ id: i + 1, label: labels[i], x, y });
    el.addEventListener("mousedown", startDrag);
    el.addEventListener("contextmenu", handleNodeContextMenu);
  }
}

function clearAll() {
  nodes = [];
  edges = [];
  selectedNodeId = null;
  document.querySelectorAll(".node").forEach((n) => n.remove());
  updateStatus();
}

// ----------- CONNECTION & MODE -------------

function toggleDirected(d) {
  isDirected = d;
  if (d) {
    directedBtn.classList.add("bg-green-500", "text-white");
    directedBtn.classList.remove("bg-gray-300", "text-gray-700");
    undirectedBtn.classList.remove("bg-green-500", "text-white");
    undirectedBtn.classList.add("bg-gray-300", "text-gray-700");
  } else {
    undirectedBtn.classList.add("bg-green-500", "text-white");
    undirectedBtn.classList.remove("bg-gray-300", "text-gray-700");
    directedBtn.classList.remove("bg-green-500", "text-white");
    directedBtn.classList.add("bg-gray-300", "text-gray-700");
  }
}

function updateStatus() {
  const n = nodes.find((n) => n.id === selectedNodeId);
  if (n) {
    connectionStatus.textContent = "Source: " + n.label;
    connectionStatus.classList.remove("bg-red-500");
    connectionStatus.classList.add("bg-blue-600");
  } else {
    connectionStatus.textContent = "Source: None";
    connectionStatus.classList.add("bg-red-500");
    connectionStatus.classList.remove("bg-blue-600");
  }
}

function handleNodeContextMenu(e) {
  e.preventDefault();
  const id = parseInt(e.currentTarget.id.split("-")[1]);
  if (!selectedNodeId) {
    document.querySelectorAll(".node").forEach((n) => n.classList.remove("selected"));
    selectedNodeId = id;
    e.currentTarget.classList.add("selected");
    updateStatus();
    return;
  }

  const targetId = id;
  if (targetId === selectedNodeId) return;

  const key = `${selectedNodeId}->${targetId}`;
  const newEdge = { fromId: selectedNodeId, toId: targetId };
  edges.push(newEdge);

  const groupEdges = edges.filter((e) => `${e.fromId}->${e.toId}` === key);
  groupEdges.forEach((edge, i) => {
    edge.groupIndex = i;
    edge.groupCount = groupEdges.length;
  });

  document.getElementById(`node-${selectedNodeId}`).classList.remove("selected");
  selectedNodeId = null;
  updateStatus();
}

// ----------- DRAGGING -------------

function startDrag(e) {
  if (e.button !== 0) return;
  if (selectedNodeId) {
    document.querySelectorAll(".node").forEach((n) => n.classList.remove("selected"));
    selectedNodeId = null;
    updateStatus();
  }
  e.preventDefault();
  const nodeEl = e.currentTarget;
  const rect = nodeEl.getBoundingClientRect();
  const offsetX = e.clientX - rect.left;
  const offsetY = e.clientY - rect.top;

  const move = (ev) => {
    const x = ev.clientX - offsetX + 20;
    const y = ev.clientY - offsetY + 20;
    updateNodePos(nodeEl, x, y);
  };
  const stop = () => {
    document.removeEventListener("mousemove", move);
    document.removeEventListener("mouseup", stop);
  };
  document.addEventListener("mousemove", move);
  document.addEventListener("mouseup", stop);
}

function updateNodePos(el, cx, cy) {
  const rect = container.getBoundingClientRect();
  let nx = cx - rect.left - 20;
  let ny = cy - rect.top - 20;
  nx = Math.max(0, Math.min(nx, rect.width - 40));
  ny = Math.max(0, Math.min(ny, rect.height - 40));
  el.style.left = nx + "px";
  el.style.top = ny + "px";
  const id = parseInt(el.id.split("-")[1]);
  const n = nodes.find((n) => n.id === id);
  if (n) {
    n.x = nx + 20;
    n.y = ny + 20;
  }
}

// ----------- INIT -------------
window.onload = () => {
  toggleDirected(false);
  generateNodes();
  draw();
};
window.addEventListener("resize", () => {
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
});
</script>
</body>
</html>
