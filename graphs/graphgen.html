<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph Editor</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
        }
        #canvasContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #graphCanvas {
            display: block;
            background-color: #ffffff;
        }
        .node {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #3b82f6; /* Blue */
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: grab;
            user-select: none;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
            transition: transform 0.1s ease;
        }
        .node:active {
            cursor: grabbing;
            z-index: 1000;
            transform: scale(1.1);
        }
        .node.selected {
            border: 4px solid #10b981; /* Green ring when selected for connection */
        }
        .node.dragging {
            z-index: 1000;
        }
        /* Style for the fixed control panel */
        #controlPanel {
            max-height: 100%;
            overflow-y: auto;
        }
    </style>
</head>
<body>

<!-- Canvas Container for Drawing Edges -->
<div id="canvasContainer">
    <canvas id="graphCanvas"></canvas>
    
    <!-- Fixed Control Panel (Left Side) -->
    <div id="controlPanel" class="absolute top-0 left-0 w-64 p-4 bg-white shadow-2xl rounded-br-xl z-50">
        <h2 class="text-xl font-bold text-gray-800 border-b pb-2 mb-4">Graph Editor</h2>

        <!-- Node Count Input -->
        <div class="mb-4">
            <label for="nodeCountInput" class="block text-sm font-medium text-gray-700 mb-1">Number of Nodes (A, B, C...):</label>
            <div class="flex space-x-2">
                <input type="number" id="nodeCountInput" value="5" min="1" max="26" class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                <button onclick="generateNodes()" class="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg shadow transition">Generate</button>
            </div>
        </div>

        <!-- Graph Type Toggle -->
        <div class="mb-4 p-3 bg-gray-50 rounded-lg shadow-inner">
            <label class="block text-sm font-medium text-gray-700 mb-2">Graph Type:</label>
            <div class="flex justify-between space-x-2">
                <button id="undirectedBtn" onclick="toggleDirected(false)" class="flex-1 py-2 px-3 text-sm font-semibold rounded-lg shadow transition bg-green-500 text-white">Undirected</button>
                <button id="directedBtn" onclick="toggleDirected(true)" class="flex-1 py-2 px-3 text-sm font-semibold rounded-lg shadow transition bg-gray-300 text-gray-700 hover:bg-gray-400">Directed</button>
            </div>
        </div>
        
        <!-- Connection Info -->
        <div class="mb-4 p-3 bg-red-50 rounded-lg shadow-inner border-2 border-red-200">
            <label class="block text-sm font-medium text-gray-700 mb-2 font-bold">Connection Tool:</label>
            <p class="text-sm text-gray-800 mt-1">
                Right-click a node to **SELECT** it.
            </p>
            <p class="text-sm text-gray-800 mt-1">
                Right-click a second node to **CONNECT** them.
            </p>
            <p class="text-sm text-gray-800 mt-1 italic text-red-700">
                (Left-click and drag to move nodes.)
            </p>
            <div id="connectionStatus" class="mt-3 p-2 text-center text-white font-semibold rounded-lg bg-red-500">
                Source: None
            </div>
        </div>
        
        <!-- Clear Button -->
        <button onclick="clearAll()" class="w-full py-2 px-4 text-sm font-semibold rounded-lg shadow-md transition duration-150 bg-gray-200 text-gray-700 hover:bg-gray-300">
            Clear All Nodes & Edges
        </button>

    </div>
</div>


<script>
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvasContainer');
    const nodeCountInput = document.getElementById('nodeCountInput');
    const connectionStatus = document.getElementById('connectionStatus');
    const undirectedBtn = document.getElementById('undirectedBtn');
    const directedBtn = document.getElementById('directedBtn');

    let nodes = []; // Array to store node data ({id, label, x, y})
    let edges = []; // Array to store edge data ({fromId, toId, groupIndex})
    let isDirected = false;
    let selectedNodeId = null; // Stores the ID of the first node right-clicked
    let draggedNode = null;

    // --- Utility Functions ---

    function getMousePos(event) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: event.clientX - rect.left,
            y: event.clientY - rect.top
        };
    }

    // --- Drawing Functions ---

    /**
     * Draws a curved arrowhead following the Bezier curve tangent.
     */
    function drawArrowhead(p1x, p1y, cx, cy, p2x, p2y) {
        const headLength = 10;
        const nodeRadius = 20;

        // Find a point T close to the end point P2 on the curve (e.g., at t=0.95)
        // This gives the tangent direction for the arrowhead
        const t = 0.95; 
        
        // Quadratic Bezier Formula: B(t) = (1-t)^2 * P1 + 2(1-t)t * C + t^2 * P2
        const t2 = t * t;
        const t1 = 1 - t;
        const t12 = t1 * t1;

        const tx = t12 * p1x + 2 * t1 * t * cx + t2 * p2x;
        const ty = t12 * p1y + 2 * t1 * t * cy + t2 * p2y;

        // The angle is calculated based on the line segment from T (t=0.95) to P2 (t=1.0)
        const angle = Math.atan2(p2y - ty, p2x - tx);
        
        // Calculate the arrow position slightly offset from the node center
        const arrowX = p2x - nodeRadius * Math.cos(angle);
        const arrowY = p2y - nodeRadius * Math.sin(angle);

        ctx.fillStyle = '#6b7280';
        ctx.beginPath();
        ctx.moveTo(arrowX, arrowY);
        ctx.lineTo(arrowX - headLength * Math.cos(angle - Math.PI / 6), arrowY - headLength * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(arrowX - headLength * Math.cos(angle + Math.PI / 6), arrowY - headLength * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fill();
    }
    
    function draw() {
        // Resize canvas to fill container
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // --- Draw Edges ---
        ctx.strokeStyle = '#6b7280'; // Gray color for edges
        ctx.lineWidth = 2;
        
        edges.forEach(edge => {
            const fromNode = nodes.find(n => n.id === edge.fromId);
            const toNode = nodes.find(n => n.id === edge.toId);
            
            if (fromNode && toNode) {
                const startX = fromNode.x;
                const startY = fromNode.y;
                const endX = toNode.x;
                const endY = toNode.y;

                // Calculate Control Point for Curvature (Quadratic Bezier)
                let ctrlX = (startX + endX) / 2;
                let ctrlY = (startY + endY) / 2;
                const offsetX = endY - startY; // Perpendicular vector component X
                const offsetY = startX - endX; // Perpendicular vector component Y
                const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
                
                // Normalization
                const normalX = distance === 0 ? 0 : offsetX / distance;
                const normalY = distance === 0 ? 0 : offsetY / distance;

                // Base magnitude for offset
                const baseOffsetMagnitude = 80; 
                
                // Use the persistent groupIndex assigned when the edge was created
                let offsetMultiplier = 0;
                
                // Calculate offset multiplier based on groupIndex
                // This ensures edges are evenly spaced around the center
                if (edge.groupIndex !== undefined && edge.groupCount !== undefined) {
                    offsetMultiplier = edge.groupIndex - (edge.groupCount - 1) / 2;
                }
                
                const curveOffset = offsetMultiplier * baseOffsetMagnitude;

                // Apply offset to control point
                ctrlX += normalX * curveOffset;
                ctrlY += normalY * curveOffset;

                // Draw Edge using Quadratic Bezier Curve
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
                ctx.stroke();

                // Draw arrowhead if directed
                if (isDirected) {
                    drawArrowhead(startX, startY, ctrlX, ctrlY, endX, endY);
                }
            }
        });

        // Loop to keep drawing
        requestAnimationFrame(draw);
    }

    // --- Node Management ---

    /**
     * Generates and places nodes on the canvas.
     */
    function generateNodes() {
        const count = parseInt(nodeCountInput.value);
        if (isNaN(count) || count < 1 || count > 26) {
            console.error("Node count must be between 1 and 26.");
            return;
        }

        // Clear existing elements and data
        clearAll();

        // Node letter labels (A, B, C, ...)
        const labels = Array.from({ length: count }, (_, i) => String.fromCharCode(65 + i));

        // Calculate a safe area for node placement (avoiding controls)
        const minX = 280; // Right of the control panel
        const minY = 50;
        const maxX = canvas.width - 50;
        const maxY = canvas.height - 50;

        labels.forEach((label, index) => {
            const nodeEl = document.createElement('div');
            // Use index + 1 as unique ID
            const nodeId = index + 1; 

            // Random initial position within safe bounds
            const x = Math.random() * (maxX - minX) + minX;
            const y = Math.random() * (maxY - minY) + minY;

            nodeEl.className = 'node';
            nodeEl.id = `node-${nodeId}`;
            nodeEl.textContent = label;
            nodeEl.style.left = `${x - 20}px`; // Center the element
            nodeEl.style.top = `${y - 20}px`;

            // Add to DOM
            container.appendChild(nodeEl);

            // Add to internal data structure
            nodes.push({ id: nodeId, label: label, x: x, y: y });

            // Attach drag (left-click) and connection (right-click) listeners
            nodeEl.addEventListener('mousedown', startDrag);
            nodeEl.addEventListener('touchstart', startDrag);
            nodeEl.addEventListener('contextmenu', handleNodeContextMenu); // Right-click listener
        });
    }
    
    /**
     * Clears all nodes and edges.
     */
    function clearAll() {
        nodes = [];
        edges = [];
        selectedNodeId = null;
        document.querySelectorAll('.node').forEach(n => n.remove());
        
        updateConnectionStatus();
    }

    // --- Mode Handlers ---
    
    /**
     * Toggles between directed and undirected graph types.
     * @param {boolean} directed 
     */
    function toggleDirected(directed) {
        isDirected = directed;
        if (isDirected) {
            directedBtn.classList.replace('bg-gray-300', 'bg-green-500');
            directedBtn.classList.replace('text-gray-700', 'text-white');
            directedBtn.classList.add('shadow-md');
            undirectedBtn.classList.replace('bg-green-500', 'bg-gray-300');
            undirectedBtn.classList.remove('shadow-md');
            undirectedBtn.classList.replace('text-white', 'text-gray-700');
        } else {
            undirectedBtn.classList.replace('bg-gray-300', 'bg-green-500');
            undirectedBtn.classList.replace('text-gray-700', 'text-white');
            undirectedBtn.classList.add('shadow-md');
            directedBtn.classList.replace('bg-green-500', 'bg-gray-300');
            directedBtn.classList.remove('shadow-md');
            directedBtn.classList.replace('text-white', 'text-gray-700');
        }
    }

    /**
     * Updates the status panel to show the selected source node.
     */
    function updateConnectionStatus() {
        const sourceNode = nodes.find(n => n.id === selectedNodeId);
        if (sourceNode) {
            connectionStatus.textContent = `Source: ${sourceNode.label}`;
            connectionStatus.classList.remove('bg-red-500');
            connectionStatus.classList.add('bg-blue-600');
        } else {
            connectionStatus.textContent = 'Source: None';
            connectionStatus.classList.add('bg-red-500');
            connectionStatus.classList.remove('bg-blue-600');
        }
    }

    /**
     * Handles right-clicks on nodes for connection logic.
     * @param {MouseEvent} e 
     */
    function handleNodeContextMenu(e) {
        e.preventDefault(); // IMPORTANT: Prevent the browser's default context menu
        
        const nodeEl = e.currentTarget;
        const nodeId = parseInt(nodeEl.id.split('-')[1]);
        
        // 1. First right-click: Select the starting node
        if (selectedNodeId === null) {
            // Remove selection from any previously selected node
            document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
            
            selectedNodeId = nodeId;
            nodeEl.classList.add('selected');
            updateConnectionStatus();
        } 
        // 2. Second right-click: Connect to the target node
        else {
            const targetNodeId = nodeId;
            
            if (selectedNodeId !== targetNodeId) {
                // Create normalized keys for both possible edge directions
                const edgeKey = [selectedNodeId, targetNodeId].sort((a, b) => a - b).join('-');
                
                // Find all edges in this group (both directions)
                const groupEdges = [];
                edges.forEach(edge => {
                    const key = [edge.fromId, edge.toId].sort((a, b) => a - b).join('-');
                    if (key === edgeKey) {
                        groupEdges.push(edge);
                    }
                });
                
                // Create new edge
                const newEdge = { 
                    fromId: selectedNodeId, 
                    toId: targetNodeId
                };
                edges.push(newEdge);
                
                // Add the new edge to our group
                groupEdges.push(newEdge);
                
                // Now assign proper indices to ALL edges in the group
                groupEdges.forEach((edge, index) => {
                    edge.groupIndex = index;
                    edge.groupCount = groupEdges.length;
                });
                
                console.log(`Added edge ${selectedNodeId}->${targetNodeId}, group size: ${groupEdges.length}`);
            }

            // Reset selection state
            document.getElementById(`node-${selectedNodeId}`).classList.remove('selected');
            selectedNodeId = null;
            updateConnectionStatus();
        }
    }

    // --- Drag Logic (Left-Click) ---

    function updateNodePosition(nodeEl, clientX, clientY) {
        // Calculate new position relative to the container
        const rect = container.getBoundingClientRect();
        let newX = clientX - rect.left - 20; // -20 to center the 40px element
        let newY = clientY - rect.top - 20;

        // Keep within bounds
        newX = Math.max(0, Math.min(newX, rect.width - 40));
        newY = Math.max(0, Math.min(newY, rect.height - 40));
        
        nodeEl.style.left = `${newX}px`;
        nodeEl.style.top = `${newY}px`;

        // Update internal data (x and y are center coordinates)
        const nodeId = parseInt(nodeEl.id.split('-')[1]);
        const nodeData = nodes.find(n => n.id === nodeId);
        if (nodeData) {
            nodeData.x = newX + 20;
            nodeData.y = newY + 20;
        }
    }
    
    function startDrag(e) {
        // Only trigger drag on LEFT mouse button (e.button === 0) or touch
        if (e.button !== 0 && !e.touches) return;

        // Prevent connection logic if selected
        if (selectedNodeId !== null) {
             // Clear selection if user attempts to drag
             document.querySelectorAll('.node').forEach(n => n.classList.remove('selected'));
             selectedNodeId = null;
             updateConnectionStatus();
        }

        e.preventDefault();
        
        const nodeEl = e.currentTarget;
        const startX = (e.touches ? e.touches[0].clientX : e.clientX);
        const startY = (e.touches ? e.touches[0].clientY : e.clientY);
        
        // Calculate offset (difference between mouse position and element's left/top corner)
        const rect = nodeEl.getBoundingClientRect();
        const offsetX = startX - rect.left;
        const offsetY = startY - rect.top;
        
        nodeEl.classList.add('dragging');
        
        const moveHandler = (e) => {
            const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
            const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
            
            // Adjust position by subtracting the offset
            // We use clientX/Y - offsetX/Y to align the mouse with the drag point
            updateNodePosition(nodeEl, clientX - offsetX + 20, clientY - offsetY + 20);
        };

        const endHandler = () => {
            document.removeEventListener('mousemove', moveHandler);
            document.removeEventListener('mouseup', endHandler);
            document.removeEventListener('touchmove', moveHandler);
            document.removeEventListener('touchend', endHandler);
            nodeEl.classList.remove('dragging');
        };

        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endHandler);
        document.addEventListener('touchmove', moveHandler);
        document.addEventListener('touchend', endHandler);
    }
    

    // --- Initialization ---

    window.onload = function() {
        // Set initial graph type to Undirected
        toggleDirected(false);
        // Generate default 5 nodes
        generateNodes();
        // Start the drawing loop
        draw();
    };

    // Handle window resize to keep canvas full screen
    window.addEventListener('resize', () => {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        // Redraw will be handled by requestAnimationFrame
    });

</script>
</body>
</html>
