<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=0.9">
    <title>Advanced Graph Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(90deg, #2c3e50, #4a235a);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
            gap: 20px;
        }
        
.graph-section {
    flex: 1; /* Takes remaining space */
    min-width: 600px;
}

.controls-section {
    width: 350px; /* Fixed width */
    min-width: 350px;
    flex: none; /* Don't grow or shrink */
}
        
        .canvas-container {
            border: 2px solid #34495e;
            border-radius: 10px;
            overflow: hidden;
            background-color: #f8f9fa;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            width: 100%;
        }
        
        #graphCanvas {
            display: block;
            width: 100%;
            height: 768px;
            background-color: white;
            cursor: pointer;
        }
        
        .controls {
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #bdc3c7;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }
        
        .checkbox-group label {
            display: flex;
            align-items: center;
            margin-bottom: 0;
            font-weight: normal;
            cursor: pointer;
        }
        
        .checkbox-group input {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        #generateBtn {
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            color: white;
        }
        
        #generateBtn:hover {
            background: linear-gradient(90deg, #219653, #27ae60);
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(39, 174, 96, 0.4);
        }
        
        #randomizeBtn {
            background: linear-gradient(90deg, #e67e22, #f39c12);
            color: white;
        }
        
        #randomizeBtn:hover {
            background: linear-gradient(90deg, #d35400, #e67e22);
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(230, 126, 34, 0.4);
        }
        
        .matrix-section {
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .matrix-section h2 {
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #bdc3c7;
            padding-bottom: 8px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
        
        th, td {
            border: 1px solid #bdc3c7;
            padding: 8px;
            text-align: center;
        }
        
        th {
            background-color: #34495e;
            color: white;
            font-weight: 600;
        }
        
        .matrix-cell {
            width: 40px;
            height: 40px;
            text-align: center;
            border: 1px solid #bdc3c7;
            border-radius: 3px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .matrix-cell:hover {
            transform: scale(1.1);
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.7);
        }
        
        .matrix-cell.diagonal {
            background-color: #f5f5f5;
        }
        
        .matrix-cell.connected {
            background-color: #d5f5e3;
            color: #27ae60;
        }
        
        .matrix-cell.directed {
            background-color: #d6eaf8;
            color: #2980b9;
        }
        
        .matrix-cell.self-loop {
            background-color: #fadbd8;
            color: #e74c3c;
        }
        
        .properties-section {
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
        }
        
        .properties-section h2 {
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #bdc3c7;
            padding-bottom: 8px;
        }
        
        .properties-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .property-section {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
        }
        
        .property-section h3 {
            margin-bottom: 12px;
            color: #2c3e50;
            border-bottom: 1px solid #ecf0f1;
            padding-bottom: 5px;
        }
        
        .property-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px dashed #ecf0f1;
        }
        
        .property-name {
            font-weight: 600;
            color: #34495e;
        }
        
        .property-value {
            font-weight: 600;
        }
        
        .true-value {
            color: #27ae60;
        }
        
        .false-value {
            color: #e74c3c;
        }
        
        .degree-list, .clustering-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid #ecf0f1;
            border-radius: 5px;
            padding: 10px;
        }
        
        .degree-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px dotted #ecf0f1;
        }
        
        footer {
            text-align: center;
            padding: 15px;
            background-color: #2c3e50;
            color: white;
            margin-top: 20px;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .graph-section, .controls-section {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Advanced Graph Generator</h1>
            <p class="subtitle">Visualize and analyze graph properties in real-time</p>
        </header>
        
        <div class="main-content">
            <div class="graph-section">
                <h2>Resulting Graph</h2>
                    <p>You can drag nodes and change connections by editing the Adjacency Matrix below.</p>
                <div class="canvas-container">

                    <canvas id="graphCanvas" width="940" height="768"></canvas>
                </div>
                
                <div class="matrix-section">
                    <h2>Adjacency Matrix (click entries to change values)</h2>
                    <div id="matrixDisplay"></div>
                </div>
            </div>
            
            <div class="controls-section">
                <div class="controls">
                    <div class="control-group">
                        <label for="nodeCount">Number of Nodes (1-26):</label>
                        <input type="number" id="nodeCount" value="6" min="1" max="26">
                    </div>
                    
                    <div class="control-group">
                        <label>Graph Options:</label>
                        <div class="checkbox-group">
                            <label><input type="checkbox" id="allowSelfLoops"> Allow Self-Loops</label>
                            <label><input type="checkbox" id="directedGraph"> Directed Graph</label>
                            <label><input type="checkbox" id="curvedEdges" checked> Curved Edges</label>
                        </div>
                    </div>
                    
                    <div class="buttons">
                        <button id="generateBtn">Generate Graph</button>
                        <button id="randomizeBtn">Randomize Matrix</button>
                    </div>
                </div>
                
                <div class="properties-section">
                    <h2>Graph Properties</h2>
                    <div id="propertiesDisplay">
                        <p>Generate a graph to see its properties...</p>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Graph Theory Visualizer &copy; 2025 | Interactive Graph Analysis Tool | Created by Alex P. using DeepSeek AI</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Get DOM elements
            const canvas = document.getElementById('graphCanvas');
            const ctx = canvas.getContext('2d');
            const nodeCountInput = document.getElementById('nodeCount');
            const generateBtn = document.getElementById('generateBtn');
            const randomizeBtn = document.getElementById('randomizeBtn');
            const matrixDisplay = document.getElementById('matrixDisplay');
            const propertiesDisplay = document.getElementById('propertiesDisplay');
            const allowSelfLoopsCheckbox = document.getElementById('allowSelfLoops');
            const directedGraphCheckbox = document.getElementById('directedGraph');
            const curvedEdgesCheckbox = document.getElementById('curvedEdges');

            // Graph data
            let nodes = [];
            let adjacencyMatrix = [];
            let selectedNode = null;
            let offsetX = 0;
            let offsetY = 0;
            let isDragging = false;

            // Generate random adjacency matrix
            function generateAdjacencyMatrix(nodeCount, allowSelfLoops, isDirected) {
                const matrix = Array(nodeCount).fill().map(() => Array(nodeCount).fill(0));
                
                for (let i = 0; i < nodeCount; i++) {
                    for (let j = 0; j < nodeCount; j++) {
                        if (i === j) {
                            // Self-loops
                            if (allowSelfLoops && Math.random() < 0.1) {
                                matrix[i][j] = 2;
                            }
                        } else {
                            // Regular connections
                            if (Math.random() < 0.3) {
                                matrix[i][j] = 1;
                                
                                // For undirected graphs, set symmetric connection
                                if (!isDirected) {
                                    matrix[j][i] = 1;
                                }
                            }
                        }
                    }
                }
                
                return matrix;
            }

            // Create node objects with positions
            function createNodes(nodeCount) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = Math.min(centerX, centerY) * 0.8;
                const nodes = [];
                
                for (let i = 0; i < nodeCount; i++) {
                    const angle = (i / nodeCount) * 2 * Math.PI;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    
                    // Generate a color based on node index
                    const hue = (i * 137.5) % 360; // Golden angle for distribution
                    const color = `hsl(${hue}, 70%, 65%)`;
                    const textColor = `hsl(${hue}, 80%, 20%)`;
                    
                    nodes.push({
                        id: i,
                        label: String.fromCharCode(65 + i), // A, B, C, ...
                        x: x,
                        y: y,
                        radius: 25,
                        color: color,
                        textColor: textColor,
                        isDragging: false
                    });
                }
                
                return nodes;
            }

            // Draw arrowhead for directed edges
            function drawArrowhead(x, y, angle, color) {
                const size = 10;
                
                ctx.save();
                ctx.fillStyle = color;
                ctx.translate(x, y);
                ctx.rotate(angle);
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-size, -size/2);
                ctx.lineTo(-size, size/2);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }

            // Calculate graph properties - FIXED degree calculation for undirected graphs
            function calculateGraphProperties() {
                const isDirected = directedGraphCheckbox.checked;
                const n = nodes.length;
                
                // Initialize properties object
                const properties = {
                    basic: {},
                    degrees: {},
                    connectivity: {},
                    clustering: {},
                    special: {}
                };
                
                // Basic properties
                properties.basic.numNodes = n;
                let numEdges = 0;
                let numSelfLoops = 0;
                
                // Degree calculations
                const inDegrees = new Array(n).fill(0);
                const outDegrees = new Array(n).fill(0);
                const degrees = new Array(n).fill(0);
                
                // Count edges and degrees - COMPLETELY REWRITTEN for correctness
                if (isDirected) {
                    // For directed graphs
                    for (let i = 0; i < n; i++) {
                        for (let j = 0; j < n; j++) {
                            if (adjacencyMatrix[i][j] === 2) {
                                // Self-loop in directed graph
                                numSelfLoops++;
                                numEdges++;
                                outDegrees[i]++;
                                inDegrees[j]++;
                            } else if (adjacencyMatrix[i][j] === 1) {
                                // Regular directed edge
                                numEdges++;
                                outDegrees[i]++;
                                inDegrees[j]++;
                            }
                        }
                    }
                    
                    // For directed graphs, total degree = inDegree + outDegree
                    for (let i = 0; i < n; i++) {
                        degrees[i] = inDegrees[i] + outDegrees[i];
                    }
                } else {
                    // For undirected graphs - COMPLETELY DIFFERENT LOGIC
                    for (let i = 0; i < n; i++) {
                        for (let j = i; j < n; j++) { // Only iterate through upper triangle to avoid double counting
                            if (i === j) {
                                // Self-loop
                                if (adjacencyMatrix[i][j] === 2) {
                                    numSelfLoops++;
                                    numEdges++;
                                    degrees[i]++; // Self-loop counts as 1 for degree
                                }
                            } else {
                                // Regular edge (only count once in the upper triangle)
                                if (adjacencyMatrix[i][j] === 1) {
                                    numEdges++;
                                    degrees[i]++;
                                    degrees[j]++;
                                }
                            }
                        }
                    }
                    
                    // For undirected graphs, in/out degrees don't apply
                    inDegrees.fill(0);
                    outDegrees.fill(0);
                }
                
                properties.basic.numEdges = numEdges;
                properties.basic.numSelfLoops = numSelfLoops;
                
                // Calculate density
                const maxEdges = isDirected ? n * (n - 1) : n * (n - 1) / 2;
                properties.basic.density = maxEdges > 0 ? (numEdges / maxEdges).toFixed(4) : 0;
                
                // Degree properties
                properties.degrees.list = [];
                let degreeSum = 0;
                let maxDegree = 0;
                let minDegree = n > 0 ? Infinity : 0;
                
                for (let i = 0; i < n; i++) {
                    const nodeDegree = degrees[i];
                    degreeSum += nodeDegree;
                    maxDegree = Math.max(maxDegree, nodeDegree);
                    minDegree = Math.min(minDegree, nodeDegree);
                    
                    properties.degrees.list.push({
                        node: nodes[i].label,
                        degree: nodeDegree,
                        inDegree: isDirected ? inDegrees[i] : 'N/A',
                        outDegree: isDirected ? outDegrees[i] : 'N/A'
                    });
                }
                
                properties.degrees.average = n > 0 ? (degreeSum / n).toFixed(2) : '0';
                properties.degrees.max = maxDegree;
                properties.degrees.min = n > 0 ? minDegree : 0;
                
                // Connectivity
                properties.connectivity.connected = isGraphConnected();
                properties.connectivity.complete = isCompleteGraph(n, numEdges, isDirected);
                properties.connectivity.regular = isRegularGraph(degrees);
                
                // Eulerian properties
                properties.special.eulerian = isEulerian(degrees, isDirected, inDegrees, outDegrees, properties.connectivity.connected);
                properties.special.semiEulerian = isSemiEulerian(degrees, isDirected, inDegrees, outDegrees, properties.connectivity.connected);

                properties.special.hamiltonian = isHamiltonian();
                
                // Clustering coefficients
                const clusteringResults = calculateClusteringCoefficients();
                properties.clustering.global = clusteringResults.global.toFixed(4);
                properties.clustering.averageLocal = clusteringResults.averageLocal.toFixed(4);
                properties.clustering.local = clusteringResults.local;
                
                return properties;
            }
            
            // Check if graph is connected using BFS
            function isGraphConnected() {
                if (nodes.length === 0) return false;
                if (nodes.length === 1) return true;
                
                const visited = new Array(nodes.length).fill(false);
                const queue = [0];
                visited[0] = true;
                let visitedCount = 1;
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    for (let i = 0; i < nodes.length; i++) {
                        if (!visited[i] && (adjacencyMatrix[current][i] === 1 || adjacencyMatrix[i][current] === 1)) {
                            visited[i] = true;
                            visitedCount++;
                            queue.push(i);
                        }
                    }
                }
                
                return visitedCount === nodes.length;
            }
            
// Check if graph is complete - FIXED to exclude graphs with self-loops
function isCompleteGraph(n, numEdges, isDirected) {
    if (n === 0) return false;
    
    // Check if there are any self-loops
    for (let i = 0; i < n; i++) {
        if (adjacencyMatrix[i][i] === 2) {
            return false; // Self-loop found, not a complete graph
        }
    }
    
    const expectedEdges = isDirected ? n * (n - 1) : n * (n - 1) / 2;
    return numEdges === expectedEdges;
}

            // Check if graph is regular
            function isRegularGraph(degrees) {
                if (degrees.length === 0) return false;
                const firstDegree = degrees[0];
                return degrees.every(degree => degree === firstDegree);
            }
            
            // Check if graph is Eulerian
            function isEulerian(degrees, isDirected, inDegrees, outDegrees, connected) {
                if (!connected) return false;
                
                if (isDirected) {
                    // For directed graphs: all vertices must have equal in and out degree
                    for (let i = 0; i < inDegrees.length; i++) {
                        if (inDegrees[i] !== outDegrees[i]) return false;
                    }
                    return true;
                } else {
                    // For undirected graphs: all vertices must have even degree
                    return degrees.every(degree => degree % 2 === 0);
                }
            }
            
            // Check if graph is semi-Eulerian
            function isSemiEulerian(degrees, isDirected, inDegrees, outDegrees, connected) {
                if (!connected) return false;
                
                if (isDirected) {
                    // For directed graphs: exactly one vertex has outDegree = inDegree + 1,
                    // exactly one vertex has inDegree = outDegree + 1, and all others have equal in/out degree
                    let startCandidates = 0;
                    let endCandidates = 0;
                    
                    for (let i = 0; i < inDegrees.length; i++) {
                        const diff = outDegrees[i] - inDegrees[i];
                        if (diff === 1) startCandidates++;
                        else if (diff === -1) endCandidates++;
                        else if (diff !== 0) return false;
                    }
                    
                    return startCandidates === 1 && endCandidates === 1;
                } else {
                    // For undirected graphs: exactly 0 or 2 vertices have odd degree
                    const oddDegreeCount = degrees.filter(degree => degree % 2 !== 0).length;
                    return oddDegreeCount === 0 || oddDegreeCount === 2;
                }
            }

            // Check if graph is Hamiltonian
function isHamiltonian() {
    if (nodes.length === 0) return false;
    if (nodes.length === 1) return true;
    
    const n = nodes.length;
    
    // Use Dirac's theorem: if n ≥ 3 and every vertex has degree ≥ n/2, then Hamiltonian
    if (n >= 3) {
        const minDegreeRequired = Math.floor(n / 2);
        for (let i = 0; i < n; i++) {
            let degree = 0;
            for (let j = 0; j < n; j++) {
                if (adjacencyMatrix[i][j] === 1 || adjacencyMatrix[j][i] === 1) {
                    degree++;
                }
            }
            if (degree < minDegreeRequired) {
                return "Unknown"; // Can't guarantee by Dirac's theorem
            }
        }
        return true; // Hamiltonian by Dirac's theorem
    }
    
    // For small graphs or when Dirac's theorem doesn't apply, use backtracking
    return hasHamiltonianCycle() ? true : "Unknown";
}

// Check for Hamiltonian cycle using backtracking (for small graphs)
function hasHamiltonianCycle() {
    const n = nodes.length;
    if (n === 0) return false;
    
    const path = new Array(n).fill(-1);
    path[0] = 0; // Start from vertex 0
    
    if (!hamiltonianUtil(path, 1)) {
        return false;
    }
    return true;
}

// Utility function for Hamiltonian cycle backtracking
function hamiltonianUtil(path, pos) {
    const n = nodes.length;
    
    // If all vertices are included in the path
    if (pos === n) {
        // Check if there's an edge from last vertex to first vertex
        return adjacencyMatrix[path[pos - 1]][path[0]] === 1;
    }
    
    // Try different vertices as next candidate
    for (let v = 1; v < n; v++) {
        if (isSafe(v, path, pos)) {
            path[pos] = v;
            
            if (hamiltonianUtil(path, pos + 1)) {
                return true;
            }
            
            path[pos] = -1; // Backtrack
        }
    }
    return false;
}

// Check if vertex can be added to Hamiltonian path
function isSafe(v, path, pos) {
    // Check if this vertex is adjacent to the previous vertex
    if (adjacencyMatrix[path[pos - 1]][v] === 0) {
        return false;
    }
    
    // Check if the vertex has already been included
    for (let i = 0; i < pos; i++) {
        if (path[i] === v) {
            return false;
        }
    }
    
    return true;
}











            
            // Calculate clustering coefficients
 

// Calculate clustering coefficients - FIXED VERSION
function calculateClusteringCoefficients() {
    const n = nodes.length;
    const localCoefficients = [];
    let globalSum = 0;
    let totalTriangles = 0;
    let totalConnectedTriples = 0;

    // Calculate local coefficients and collect data for global
    for (let i = 0; i < n; i++) {
        const neighbors = [];
        
        // Find all neighbors of node i
        for (let j = 0; j < n; j++) {
            if (i !== j && adjacencyMatrix[i][j] === 1) {
                neighbors.push(j);
            }
        }
        
        const k = neighbors.length;
        
        // If node has fewer than 2 neighbors, clustering coefficient is 0
        if (k < 2) {
            localCoefficients.push({ node: nodes[i].label, coefficient: 0 });
            continue;
        }
        
        // Count triangles (connections between neighbors)
        let triangles = 0;
        for (let a = 0; a < k; a++) {
            for (let b = a + 1; b < k; b++) {
                if (adjacencyMatrix[neighbors[a]][neighbors[b]] === 1) {
                    triangles++;
                }
            }
        }
        
        // Calculate local clustering coefficient
        const maxPossibleTriangles = k * (k - 1) / 2;
        const localCoefficient = maxPossibleTriangles > 0 ? triangles / maxPossibleTriangles : 0;
        
        localCoefficients.push({ node: nodes[i].label, coefficient: localCoefficient });
        globalSum += localCoefficient;
        
        // For global coefficient calculation
        totalTriangles += triangles;
        totalConnectedTriples += k * (k - 1) / 2;
    }
    
    // Calculate GLOBAL clustering coefficient (transitivity)
    const globalCoefficient = totalConnectedTriples > 0 ? totalTriangles / totalConnectedTriples : 0;
    
    // Calculate AVERAGE LOCAL clustering coefficient
    const averageLocalCoefficient = n > 0 ? globalSum / n : 0;
    
    return {
        global: globalCoefficient,
        averageLocal: averageLocalCoefficient,  // Now they can differ!
        local: localCoefficients
    };
}



            
            // Display graph properties
            function displayGraphProperties() {
                // Check if we have a graph to analyze
                if (nodes.length === 0 || adjacencyMatrix.length === 0) {
                    propertiesDisplay.innerHTML = '<p>Generate a graph to see its properties...</p>';
                    return;
                }
                
                const properties = calculateGraphProperties();
                const isDirected = directedGraphCheckbox.checked;
                
                let html = `
                    <div class="properties-grid">
                        <div class="property-section">
                            <h3>Basic Properties</h3>
                            <div class="property-item">
                                <span class="property-name">Number of Nodes:</span>
                                <span class="property-value">${properties.basic.numNodes}</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">Number of Edges:</span>
                                <span class="property-value">${properties.basic.numEdges}</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">Number of Self-Loops:</span>
                                <span class="property-value">${properties.basic.numSelfLoops}</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">Graph Density:</span>
                                <span class="property-value">${properties.basic.density}</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">Graph Type:</span>
                                <span class="property-value">${isDirected ? 'Directed' : 'Undirected'}</span>
                            </div>
                        </div>
                        
                        <div class="property-section">
                            <h3>Degree Information</h3>
                            <div class="property-item">
                                <span class="property-name">Average Degree:</span>
                                <span class="property-value">${properties.degrees.average}</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">Maximum Degree:</span>
                                <span class="property-value">${properties.degrees.max}</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">Minimum Degree:</span>
                                <span class="property-value">${properties.degrees.min}</span>
                            </div>
                            <div class="degree-list">
                                ${properties.degrees.list.map(item => `
                                    <div class="degree-item">
                                        <span>Node ${item.node}:</span>
                                        <span>${isDirected ? `in=${item.inDegree}, out=${item.outDegree}` : `degree=${item.degree}`}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
 

<div class="property-section">
    <h3>Special Properties</h3>
    <div class="property-item">
        <span class="property-name">Eulerian:
            <span title="Eulerian Graph: Has an Eulerian circuit - visits every edge exactly once and returns to starting vertex. Undirected: all vertices have even degree. Directed: all vertices have equal in/out degree.">ⓘ</span>
        </span>
        <span class="property-value ${properties.special.eulerian ? 'true-value' : 'false-value'}">
            ${properties.special.eulerian ? 'Yes' : 'No'}
        </span>
    </div>
    <div class="property-item">
        <span class="property-name">Semi-Eulerian:
            <span title="Semi-Eulerian Graph: Has an Eulerian path but not a circuit - visits every edge exactly once, starts and ends at different vertices. Undirected: exactly 0 or 2 vertices have odd degree. Directed: one vertex has out=in+1, one has in=out+1.">ⓘ</span>
        </span>
        <span class="property-value ${properties.special.semiEulerian ? 'true-value' : 'false-value'}">
            ${properties.special.semiEulerian ? 'Yes' : 'No'}
        </span>
    </div>
    <div class="property-item">
        <span class="property-name">Hamiltonian:
            <span title="Hamiltonian Graph: Has a Hamiltonian cycle - visits every vertex exactly once and returns to starting vertex. Note: Determining if a graph is Hamiltonian is computationally difficult (NP-complete). This uses Dirac's theorem for certain cases.">ⓘ</span>
        </span>
        <span class="property-value ${
            properties.special.hamiltonian === true ? 'true-value' : 
            properties.special.hamiltonian === false ? 'false-value' : 'unknown-value'
        }">
            ${
                properties.special.hamiltonian === true ? 'Yes' : 
                properties.special.hamiltonian === false ? 'No' : 'Unknown'
            }
        </span>
    </div>
</div>
 
                        
                        <div class="property-section">
                            <h3>Clustering Coefficients</h3>
                            <div class="property-item">
                                <span class="property-name">Global Coefficient:</span>
                                <span class="property-value">${properties.clustering.global}</span>
                            </div>
                            <div class="property-item">
                                <span class="property-name">Average Local Coefficient:</span>
                                <span class="property-value">${properties.clustering.averageLocal}</span>
                            </div>
                            <div class="degree-list">
                                ${properties.clustering.local.map(item => `
                                    <div class="degree-item">
                                        <span>Node ${item.node}:</span>
                                        <span>${item.coefficient.toFixed(4)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
                
                propertiesDisplay.innerHTML = html;
            }

            // Draw the graph
            function drawGraph() {
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const isDirected = directedGraphCheckbox.checked;
                const useCurvedEdges = curvedEdgesCheckbox.checked;
                
                // Draw edges
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = 0; j < nodes.length; j++) {
                        if (adjacencyMatrix[i][j] > 0) {
                            // Self-loops
                            if (i === j && adjacencyMatrix[i][j] === 2) {
                                const node = nodes[i];
                                
                                ctx.strokeStyle = '#e74c3c';
                                ctx.lineWidth = 3;
                                
                                // Draw self-loop as bezier curve
                                const startAngle = Math.PI * 0.2;
                                const endAngle = Math.PI * 1.8;
                                const loopRadius = node.radius * 2;
                                
                                // Control points for bezier curve
                                const cp1x = node.x + loopRadius * Math.cos(startAngle);
                                const cp1y = node.y - loopRadius * Math.sin(startAngle);
                                const cp2x = node.x + loopRadius * Math.cos(endAngle);
                                const cp2y = node.y - loopRadius * Math.sin(endAngle);
                                
                                ctx.beginPath();
                                ctx.moveTo(node.x + node.radius * Math.cos(startAngle), 
                                          node.y - node.radius * Math.sin(startAngle));
                                ctx.bezierCurveTo(
                                    cp1x, cp1y,
                                    cp2x, cp2y,
                                    node.x + node.radius * Math.cos(endAngle),
                                    node.y - node.radius * Math.sin(endAngle)
                                );
                                ctx.stroke();
                                
                                // Add arrowhead for self-loop
                                const arrowAngle = Math.PI * 1.5;
                                const arrowX = node.x + node.radius * Math.cos(endAngle);
                                const arrowY = node.y - node.radius * Math.sin(endAngle);
                                drawArrowhead(arrowX, arrowY, arrowAngle, '#e74c3c');
                            } 
                            // Regular connections
                            else if (i !== j) {
                                const node1 = nodes[i];
                                const node2 = nodes[j];
                                
                                // Determine if this is a bidirectional connection
                                const isBidirectional = !isDirected && adjacencyMatrix[j][i] === 1;
                                
                                // Set color and line width based on connection type
                                if (isBidirectional) {
                                    ctx.strokeStyle = '#4a6ee0';
                                    ctx.lineWidth = 2;
                                } else {
                                    ctx.strokeStyle = '#27ae60';
                                    ctx.lineWidth = 2;
                                }
                                
                                // Calculate direction and control points for bezier curve
                                const dx = node2.x - node1.x;
                                const dy = node2.y - node1.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                const unitX = dx / dist;
                                const unitY = dy / dist;
                                
                                // Start and end points (offset by node radius)
                                const startX = node1.x + unitX * node1.radius;
                                const startY = node1.y + unitY * node1.radius;
                                const endX = node2.x - unitX * node2.radius;
                                const endY = node2.y - unitY * node2.radius;
                                
                                if (useCurvedEdges && !isBidirectional) {
                                    // Calculate control point for bezier curve with reduced curvature (0.1)
                                    const midX = (startX + endX) / 2;
                                    const midY = (startY + endY) / 2;
                                    
                                    // Perpendicular direction for curve
                                    const perpX = -unitY;
                                    const perpY = unitX;
                                    
                                    // Curve magnitude (reduced to 0.1 for less curvature)
                                    const curveMagnitude = dist * 0.1;
                                    
                                    const controlX = midX + perpX * curveMagnitude;
                                    const controlY = midY + perpY * curveMagnitude;
                                    
                                    // Draw bezier curve
                                    ctx.beginPath();
                                    ctx.moveTo(startX, startY);
                                    ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                                    ctx.stroke();
                                    
                                    // Draw arrowhead for directed edge
                                    if (isDirected) {
                                        const arrowAngle = Math.atan2(endY - controlY, endX - controlX);
                                        drawArrowhead(endX, endY, arrowAngle, '#27ae60');
                                    }
                                } else {
                                    // Draw straight line
                                    ctx.beginPath();
                                    ctx.moveTo(startX, startY);
                                    ctx.lineTo(endX, endY);
                                    ctx.stroke();
                                    
                                    // Draw arrowhead for directed edge
                                    if (isDirected) {
                                        const arrowAngle = Math.atan2(dy, dx);
                                        drawArrowhead(endX, endY, arrowAngle, '#27ae60');
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Draw nodes
                for (const node of nodes) {
                    // Draw node circle
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                    ctx.fillStyle = node.color;
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw node label
                    ctx.fillStyle = node.textColor;
                    ctx.font = 'bold 18px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.label, node.x, node.y);
                }
                
                // Update properties display
                displayGraphProperties();
            }
            
            // Display adjacency matrix as HTML table with editable cells
            function displayMatrix(matrix) {
                const allowSelfLoops = allowSelfLoopsCheckbox.checked;
                const isDirected = directedGraphCheckbox.checked;
                
                let html = '<table>';
                
                // Header row
                html += '<tr><th></th>';
                for (let i = 0; i < matrix.length; i++) {
                    html += `<th>${String.fromCharCode(65 + i)}</th>`;
                }
                html += '</tr>';
                
                // Data rows
                for (let i = 0; i < matrix.length; i++) {
                    html += `<tr><th>${String.fromCharCode(65 + i)}</th>`;
                    for (let j = 0; j < matrix[i].length; j++) {
                        const cellValue = matrix[i][j];
                        let cellClass = 'matrix-cell';
                        
                        // Add diagonal class for main diagonal cells
                        if (i === j) {
                            cellClass += ' diagonal';
                        }
                        
                        if (cellValue === 2) {
                            cellClass += ' self-loop';
                        } else if (cellValue === 1) {
                            cellClass += isDirected ? ' directed' : ' connected';
                        }
                        
                        // Handle self-loops (diagonal cells)
                        if (i === j) {
                            if (allowSelfLoops) {
                                html += `<td><input type="text" class="${cellClass}" value="${cellValue}" data-row="${i}" data-col="${j}"></td>`;
                            } else {
                                html += `<td><input type="text" class="matrix-cell diagonal" value="0" readonly></td>`;
                            }
                        } else {
                            html += `<td><input type="text" class="${cellClass}" value="${cellValue}" data-row="${i}" data-col="${j}"></td>`;
                        }
                    }
                    html += '</tr>';
                }
                
                html += '</table>';
                matrixDisplay.innerHTML = html;
                
                // Add event listeners to matrix cells
                const matrixCells = document.querySelectorAll('.matrix-cell:not([readonly])');
                matrixCells.forEach(cell => {
                    cell.addEventListener('click', function() {
                        const row = parseInt(this.getAttribute('data-row'));
                        const col = parseInt(this.getAttribute('data-col'));
                        const isDirected = directedGraphCheckbox.checked;
                        
                        // Toggle the connection
                        if (row === col) {
                            // Self-loop: toggle between 0 and 2
                            adjacencyMatrix[row][col] = adjacencyMatrix[row][col] === 2 ? 0 : 2;
                        } else {
                            // Regular connection: toggle between 0 and 1
                            adjacencyMatrix[row][col] = adjacencyMatrix[row][col] === 1 ? 0 : 1;
                            
                            // For undirected graphs, update symmetric cell
                            if (!isDirected) {
                                adjacencyMatrix[col][row] = adjacencyMatrix[row][col];
                            }
                        }
                        
                        // Update the matrix display
                        displayMatrix(adjacencyMatrix);
                        
                        // Redraw the graph and update properties
                        drawGraph();
                    });
                });
            }
            
            // Find node at coordinates
            function getNodeAt(x, y) {
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const node = nodes[i];
                    const dx = node.x - x;
                    const dy = node.y - y;
                    if (dx * dx + dy * dy <= node.radius * node.radius) {
                        return node;
                    }
                }
                return null;
            }
            
            // Mouse event handlers - FIXED dragging functionality
            canvas.addEventListener('mousedown', function(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                selectedNode = getNodeAt(x, y);
                if (selectedNode) {
                    isDragging = true;
                    offsetX = x - selectedNode.x;
                    offsetY = y - selectedNode.y;
                    canvas.style.cursor = 'grabbing';
                }
            });
            
            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                if (isDragging && selectedNode) {
                    // Update node position
                    selectedNode.x = x - offsetX;
                    selectedNode.y = y - offsetY;
                    
                    // Keep node within canvas bounds
                    selectedNode.x = Math.max(selectedNode.radius, Math.min(canvas.width - selectedNode.radius, selectedNode.x));
                    selectedNode.y = Math.max(selectedNode.radius, Math.min(canvas.height - selectedNode.radius, selectedNode.y));
                    
                    drawGraph();
                } else {
                    // Change cursor when hovering over a node
                    const node = getNodeAt(x, y);
                    canvas.style.cursor = node ? 'grab' : 'default';
                }
            });
            
            canvas.addEventListener('mouseup', function() {
                isDragging = false;
                selectedNode = null;
                canvas.style.cursor = 'default';
            });
            
            canvas.addEventListener('mouseleave', function() {
                isDragging = false;
                selectedNode = null;
                canvas.style.cursor = 'default';
            });
            
            // Generate graph button handler
            generateBtn.addEventListener('click', function() {
                const nodeCount = parseInt(nodeCountInput.value);
                
                if (nodeCount < 1 || nodeCount > 26) {
                    alert('Please enter a number between 1 and 26');
                    return;
                }
                
                // Generate new graph
                const allowSelfLoops = allowSelfLoopsCheckbox.checked;
                const isDirected = directedGraphCheckbox.checked;
                adjacencyMatrix = generateAdjacencyMatrix(nodeCount, allowSelfLoops, isDirected);
                nodes = createNodes(nodeCount);
                
                // Display matrix and draw graph
                displayMatrix(adjacencyMatrix);
                drawGraph();
            });
            
            // Randomize matrix button handler
            randomizeBtn.addEventListener('click', function() {
                if (adjacencyMatrix.length > 0) {
                    const allowSelfLoops = allowSelfLoopsCheckbox.checked;
                    const isDirected = directedGraphCheckbox.checked;
                    adjacencyMatrix = generateAdjacencyMatrix(adjacencyMatrix.length, allowSelfLoops, isDirected);
                    
                    // Display matrix and draw graph
                    displayMatrix(adjacencyMatrix);
                    drawGraph();
                }
            });
            
            // Update matrix when options change
            allowSelfLoopsCheckbox.addEventListener('change', function() {
                if (adjacencyMatrix.length > 0) {
                    displayMatrix(adjacencyMatrix);
                    drawGraph();
                }
            });
            
            directedGraphCheckbox.addEventListener('change', function() {
                if (adjacencyMatrix.length > 0) {
                    const isDirected = directedGraphCheckbox.checked;
                    
                    // If switching to undirected, make matrix symmetric
                    if (!isDirected) {
                        for (let i = 0; i < adjacencyMatrix.length; i++) {
                            for (let j = i + 1; j < adjacencyMatrix.length; j++) {
                                // Use OR logic: if either cell has a connection, both should
                                const hasConnection = adjacencyMatrix[i][j] === 1 || adjacencyMatrix[j][i] === 1;
                                adjacencyMatrix[i][j] = hasConnection ? 1 : 0;
                                adjacencyMatrix[j][i] = hasConnection ? 1 : 0;
                            }
                        }
                    }
                    
                    displayMatrix(adjacencyMatrix);
                    drawGraph();
                }
            });
            
            curvedEdgesCheckbox.addEventListener('change', function() {
                if (adjacencyMatrix.length > 0) {
                    drawGraph();
                }
            });
            
            // Generate initial graph
            generateBtn.click();
            
        });
    </script>
</body>
</html>
