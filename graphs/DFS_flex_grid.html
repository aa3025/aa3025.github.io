<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DFS Grid Visualization (8-Directional)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the visualization */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Make canvas visually responsive but maintain aspect ratio */
        canvas {
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
            border: 2px solid #E5E7EB; /* gray-200 */
            border-radius: 0.5rem; /* rounded-lg */
            background-color: #FFFFFF;
        }
        /* Style for the select dropdown */
        select, input[type="number"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            padding-right: 2.5rem;
        }
        select {
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E");
        }
        /* Hide spinner buttons on number input */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
             padding-right: 0.75rem; /* 12px */
        }

        /* --- NEW Stack Pipe Visualization Styles (No Animation) --- */
        .stack-pipe-item {
            display: block; /* Stack items are full width */
            padding: 4px 10px;
            margin-top: 4px; /* Margin on top */
            font-family: monospace;
            font-size: 12px;
            font-weight: 600;
            text-align: center;
            color: #b45309; /* amber-700 */
            background-color: #fde68a; /* amber-200 */
            border-radius: 0.375rem; /* rounded-md */
            
            /* No animation properties */
            transform: scale(1);
            opacity: 1;
            /* Allow line breaks for very narrow stack */
            word-break: break-all;
        }
        /* --- End New Styles --- */
    </style>
</head>
<body class="bg-white min-h-screen flex flex-col items-center p-4">

    <!-- New Centering Wrapper -->
    <div class="w-full max-w-7xl mx-auto">
        <div class="bg-white rounded-lg p-6">
            <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">
                DFS Grid Visualization (8-Directional)
            </h1>
            
            <!-- Main container - Back to horizontal layout on large screens -->
            <div class="flex flex-col lg:flex-row gap-6">
                
                <!-- Main Content (Canvas + Controls) -->
                <div class="flex-grow">
                    <div class="flex flex-col lg:flex-row gap-6">
                        <!-- Visualization Area (Canvas) - Takes 60% width on large screens -->
                        <div class="flex-grow w-full lg:w-3/5">
                            <canvas id="dfs-canvas"></canvas> <!-- Size set by JS -->
                        </div>
                        
                        <!-- Controls and Info Panel - Takes 40% width on large screens -->
                        <div class="w-full lg:w-2/5 flex-shrink-0 space-y-4">
                            
                            <!-- Control Buttons -->
                            <div>
                                <h2 class="text-xl font-semibold text-gray-700 mb-2">Controls</h2>
                                <!-- Auto-play controls -->
                                <div class="flex space-x-2 mb-2">
                                    <button id="start-btn" class="w-full bg-green-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-200">
                                        Auto-Play
                                    </button>
                                    <button id="pause-btn" class="w-full bg-yellow-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-yellow-600 transition duration-200 disabled:opacity-50" disabled>
                                        Pause
                                    </button>
                                </div>
                                 <!-- Manual controls -->
                                <div class="flex space-x-2 mb-2">
                                    <button id="prev-btn" class="w-full bg-white text-gray-700 border border-gray-300 font-semibold py-2 px-4 rounded-lg hover:bg-gray-50 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                                        Previous
                                    </button>
                                    <button id="next-btn" class="w-full bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                                        Next
                                    </button>
                                    <button id="reset-btn" class="w-1/2 bg-white text-red-700 border border-red-400 font-semibold py-2 px-4 rounded-lg hover:bg-red-50 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                                        Reset
                                    </button>
                                </div>
                                <!-- Settings -->
                                <div class="grid grid-cols-2 gap-2">
                                    <!-- Grid Size Input -->
                                    <div>
                                        <label for="grid-size-input" class="block text-sm font-medium text-gray-700 mb-1">Grid Size (odd)</label>
                                        <input type="number" id="grid-size-input" value="21" min="3" max="51" step="2" class="w-full bg-white border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5">
                                    </div>
                                    <!-- Search Strategy -->
                                    <div>
                                        <label for="strategy-select" class="block text-sm font-medium text-gray-700 mb-1">Search Strategy</label>
                                        <select id="strategy-select" class="w-full bg-white border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5">
                                            <option value="random" selected>Random (8-way)</option>
                                            <option value="prefer-up">Prefer Up (8-way)</option>
                                            <option value="prefer-down">Prefer Down (8-way)</option>
                                            <option value="prefer-left">Prefer Left (8-way)</option>
                                            <option value="prefer-right">Prefer Right (8-way)</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <!-- Step Description -->
                            <div>
                                <h2 class="text-xl font-semibold text-gray-700 mb-1">Step Description</h2>
                                <div class="min-h-[50px] bg-white border border-gray-300 rounded-lg p-3">
                                    <p id="step-description" class="text-lg text-gray-800">Algorithm ready. Click 'Next' or 'Auto-Play'.</p>
                                </div>
                            </div>

                            <!-- Info Panel: Stats and Legend -->
                            <div class="space-y-4">
                                <!-- Stats -->
                                <div>
                                    <h2 class="text-xl font-semibold text-gray-700 mb-2">Stats</h2>
                                     <div class="mt-2 space-y-1 bg-white border border-gray-300 rounded-lg p-3">
                                        <p class="text-gray-700">Stack Size: <span id="stack-size" class="font-mono font-bold text-yellow-600">0</span></p>
                                        <p class="text-gray-700">Visited Count: <span id="visited-count" class="font-mono font-bold text-green-600">0</span></p>
                                    </div>
                                </div>
                                
                                <!-- Legend -->
                                <div>
                                    <h2 class="text-xl font-semibold text-gray-700 mb-2">Legend</h2>
                                    <div class="space-y-2 bg-white border border-gray-300 rounded-lg p-3">
                                        <div class="flex items-center">
                                            <div class="w-5 h-5 rounded-full mr-2 border border-gray-700" style="background-color: #E5E7EB"></div>
                                            <span>Unvisited Node</span>
                                        </div>
                                        <div class="flex items-center">
                                            <div class="w-5 h-5 rounded-full mr-2 border border-gray-700" style="background-color: #FCD34D"></div>
                                            <span>In Stack (Active Path)</span>
                                        </div>
                                        <div class="flex items-center">
                                            <div class="w-5 h-5 rounded-full mr-2 border border-gray-700" style="background-color: #10B981"></div>
                                            <span>Visited Node</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <!-- End of Stats and Legend Panel -->

                        </div>
                    </div>
                </div> <!-- End Main Content -->

                <!-- NEW Stack Panel on the far right (w-24) -->
                <div class="w-full lg:w-24 flex-shrink-0 space-y-2">
                    <h2 class="text-xl font-semibold text-gray-700 mb-2">Stack (Top â†‘)</h2>
                    <!-- This div holds the vertical stack -->
                    <div id="stack-pipe" class="w-full h-auto lg:h-[calc(100vh-200px)] bg-white border border-gray-300 rounded-lg p-2 flex flex-col-reverse overflow-y-auto">
                        <!-- Items will be added here by JS -->
                        <span id="stack-pipe-placeholder" class="text-gray-400 italic p-2 text-sm">Stack is empty...</span>
                    </div>
                </div>
            </div>
        </div>
    </div> <!-- End Centering Wrapper -->

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            // --- Constants ---
            let PADDING = 32; // Padding around the grid
            let NODE_RADIUS = 6; // Radius of the node dot
            
            // --- DOM Elements ---
            const canvas = document.getElementById('dfs-canvas');
            const ctx = canvas.getContext('2d');
            
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const resetBtn = document.getElementById('reset-btn');
            const startBtn = document.getElementById('start-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const strategySelect = document.getElementById('strategy-select');
            const gridSizeInput = document.getElementById('grid-size-input');
            
            const stepDescription = document.getElementById('step-description');
            const stackSizeEl = document.getElementById('stack-size');
            const visitedCountEl = document.getElementById('visited-count');

            // --- NEW Stack Pipe Elements ---
            const stackPipe = document.getElementById('stack-pipe');
            const stackPipePlaceholder = document.getElementById('stack-pipe-placeholder');
            
            const COLORS = {
                default: '#E5E7EB',   // gray-200 (unvisited node)
                inStack: '#FCD34D', // amber-300 (node in stack)
                visited: '#10B981', // emerald-500 (visited node)
                edge: '#D1D5DB',      // gray-300 (grid lines)
                diagEdge: '#E5E7EB',  // gray-200 (diagonal edges)
                nodeBorder: '#374151' // gray-700
            };

            // --- State (Dynamic) ---
            let GRID_SIZE = 21;
            let START_NODE = { x: 10, y: 10 };
            let CANVAS_WIDTH = 704;
            let CANVAS_HEIGHT = 704;
            let CELL_SPACING = 32;

            let steps = [];
            let currentStep = 0;
            let isPlaying = false;
            let timeoutId = null;
            let resizeTimer; // For debouncing resize events

            // --- Utility Functions ---

            function createGrid(size, value) {
                return Array.from({ length: size }, () => Array(size).fill(value));
            }

            function deepCopyGrid(grid) {
                return grid.map(row => [...row]);
            }
            
            function getCanvasCoords(x, y) {
                return {
                    x: PADDING + x * CELL_SPACING,
                    y: PADDING + y * CELL_SPACING
                };
            }

            /**
             * Converts a node object {x, y} to a single ID (1 to n^2)
             */
            function nodeToId(node) {
                // Use global GRID_SIZE for calculation
                return node.y * GRID_SIZE + node.x + 1;
            }

            const nodeToKey = (node) => `${node.x},${node.y}`;

            /**
             * Gets valid neighbors, prioritized by the selected strategy (8-directional).
             */
            function getPrioritizedNeighbors(x, y, strategy) {
                // All 8 directions
                const directions = {
                    'up': { x: 0, y: -1 },
                    'down': { x: 0, y: 1 },
                    'left': { x: -1, y: 0 },
                    'right': { x: 1, y: 0 },
                    'up-left': { x: -1, y: -1 },
                    'up-right': { x: 1, y: -1 },
                    'down-left': { x: -1, y: 1 },
                    'down-right': { x: 1, y: 1 }
                };
                
                let dirOrder = [];
                const neutralOrder = [
                    directions.up, directions.down, directions.left, directions.right,
                    directions['up-left'], directions['up-right'], directions['down-left'], directions['down-right']
                ];

                if (strategy === 'prefer-up') {
                    dirOrder = [
                        directions.up, directions['up-left'], directions['up-right'],
                        directions.left, directions.right, directions.down, directions['down-left'], directions['down-right']
                    ];
                } else if (strategy === 'prefer-down') {
                    dirOrder = [
                        directions.down, directions['down-left'], directions['down-right'],
                        directions.left, directions.right, directions.up, directions['up-left'], directions['up-right']
                    ];
                } else if (strategy === 'prefer-left') {
                    dirOrder = [
                        directions.left, directions['up-left'], directions['down-left'],
                        directions.up, directions.down, directions.right, directions['up-right'], directions['down-right']
                    ];
                } else if (strategy === 'prefer-right') {
                    dirOrder = [
                        directions.right, directions['up-right'], directions['down-right'],
                        directions.up, directions.down, directions.left, directions['up-left'], directions['down-left']
                    ];
                } else { // 'random'
                    dirOrder = [...neutralOrder];
                    for (let i = dirOrder.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [dirOrder[i], dirOrder[j]] = [dirOrder[j], dirOrder[i]];
                    }
                }

                const neighbors = [];
                for (const dir of dirOrder) {
                    const newX = x + dir.x;
                    const newY = y + dir.y;
                    if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                        neighbors.push({ x: newX, y: newY });
                    }
                }
                return neighbors;
            }

            // --- Drawing Function ---

            function drawGrid(gridStates) {
                // Set canvas size (might have changed)
                canvas.width = CANVAS_WIDTH;
                canvas.height = CANVAS_HEIGHT;
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
                
                // 1. Draw Diagonal Edges (Lighter)
                ctx.lineWidth = 1;
                ctx.strokeStyle = COLORS.diagEdge;
                for (let y = 0; y < GRID_SIZE - 1; y++) {
                    for (let x = 0; x < GRID_SIZE - 1; x++) {
                        const p1 = getCanvasCoords(x, y);
                        const p2 = getCanvasCoords(x + 1, y + 1);
                        ctx.beginPath();
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                        
                        const p3 = getCanvasCoords(x + 1, y);
                        const p4 = getCanvasCoords(x, y + 1);
                        ctx.beginPath();
                        ctx.moveTo(p3.x, p3.y);
                        ctx.lineTo(p4.x, p4.y);
                        ctx.stroke();
                    }
                }
                
                // 2. Draw Horizontal/Vertical Edges (Darker)
                ctx.lineWidth = 2; // Line width for edges
                ctx.strokeStyle = COLORS.edge;
                for (let i = 0; i < GRID_SIZE; i++) {
                    const p1_h = getCanvasCoords(0, i);
                    const p2_h = getCanvasCoords(GRID_SIZE - 1, i);
                    ctx.beginPath();
                    ctx.moveTo(p1_h.x, p1_h.y);
                    ctx.lineTo(p2_h.x, p2_h.y);
                    ctx.stroke();
                    
                    const p1_v = getCanvasCoords(i, 0);
                    const p2_v = getCanvasCoords(i, GRID_SIZE - 1);
                    ctx.beginPath();
                    ctx.moveTo(p1_v.x, p1_v.y);
                    ctx.lineTo(p2_v.x, p2_v.y);
                    ctx.stroke();
                }
                
                // 3. Draw Nodes (Dots)
                ctx.lineWidth = 1; // Line width for node borders
                ctx.strokeStyle = COLORS.nodeBorder;
                
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const state = gridStates[y][x];
                        const p = getCanvasCoords(x, y);
                        
                        ctx.fillStyle = COLORS[state];
                        
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, NODE_RADIUS, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke(); // Draw border
                    }
                }
            }

            // --- Algorithm Step Generation (DFS) ---

            function generateDFSSteps(strategy) {
                steps = [];
                let gridStates = createGrid(GRID_SIZE, 'default');
                let stack = []; // This stack holds {x, y} objects
                let visitedSet = new Set(); // Tracks nodes that have been visited OR are in the stack
                let visitedCount = 0;

                function findUnvisitedNeighbor(node, visitedSet) {
                    const neighbors = getPrioritizedNeighbors(node.x, node.y, strategy);
                    for (const neighbor of neighbors) {
                        if (!visitedSet.has(nodeToKey(neighbor))) {
                            return neighbor;
                        }
                    }
                    return null;
                }

                // Step 0: Initial state
                steps.push({
                    states: deepCopyGrid(gridStates),
                    stack: [], // Store stack of node IDs
                    visitedCount: 0,
                    message: "Algorithm ready. Click 'Next' or 'Auto-Play'."
                });

                // Step 1: Push start node
                stack.push(START_NODE);
                visitedSet.add(nodeToKey(START_NODE));
                gridStates[START_NODE.y][START_NODE.x] = 'inStack';
                
                steps.push({
                    states: deepCopyGrid(gridStates),
                    stack: stack.map(nodeToId), // Convert to IDs
                    visitedCount: 0,
                    message: `Push start node #${nodeToId(START_NODE)} onto stack.`
                });

                // Main DFS loop
                while (stack.length > 0) {
                    const currentNode = stack[stack.length - 1]; // Peek
                    const { x, y } = currentNode;
                    const currentNodeId = nodeToId(currentNode);

                    // --- PREORDER VISIT ---
                    if (gridStates[y][x] !== 'visited') {
                        gridStates[y][x] = 'visited';
                        visitedCount++;
                        steps.push({
                            states: deepCopyGrid(gridStates),
                            stack: stack.map(nodeToId),
                            visitedCount: visitedCount,
                            message: `Visit node #${currentNodeId}.`
                        });
                    }

                    // --- FIND NEXT CHILD ---
                    const neighbor = findUnvisitedNeighbor(currentNode, visitedSet);

                    if (neighbor) {
                        // Found an unvisited neighbor, push it onto stack
                        const neighborId = nodeToId(neighbor);
                        visitedSet.add(nodeToKey(neighbor));
                        stack.push(neighbor);
                        gridStates[neighbor.y][neighbor.x] = 'inStack';
                        steps.push({
                            states: deepCopyGrid(gridStates),
                            stack: stack.map(nodeToId),
                            visitedCount: visitedCount,
                            message: `Found unvisited neighbor. Push #${neighborId}.`
                        });
                    } else {
                        // Dead end, pop from stack (backtrack)
                        const popped = stack.pop();
                        const poppedId = nodeToId(popped);
                        // State remains 'visited'
                        steps.push({
                            states: deepCopyGrid(gridStates),
                            stack: stack.map(nodeToId),
                            visitedCount: visitedCount,
                            message: `Dead end at #${poppedId}. Backtrack (pop).`
                        });
                    }
                }
                
                // Final step
                steps.push({
                    states: deepCopyGrid(gridStates),
                    stack: [],
                    visitedCount: visitedCount,
                    message: "Traversal complete. Stack is empty."
                });
            }

            // --- Step Rendering and Navigation ---

            /**
             * Renders the stack visualization in the vertical pipe
             */
            function renderStackPipe(stackIds) {
                stackPipe.innerHTML = ''; 

                if (stackIds.length === 0) {
                    stackPipe.appendChild(stackPipePlaceholder);
                } else {
                    stackPipePlaceholder.remove();
                    
                    stackIds.forEach((id) => {
                        const item = document.createElement('div');
                        item.className = 'stack-pipe-item'; // No animation class
                        item.textContent = id;
                        stackPipe.appendChild(item);
                    });
                    
                    stackPipe.scrollTop = stackPipe.scrollHeight;
                }
            }


            function renderStep(index) {
                if (index < 0 || index >= steps.length) return;

                currentStep = index;
                const step = steps[currentStep];

                drawGrid(step.states);
                stepDescription.textContent = step.message;
                stackSizeEl.textContent = step.stack.length;
                visitedCountEl.textContent = step.visitedCount;
                renderStackPipe(step.stack);

                prevBtn.disabled = (currentStep === 0);
                nextBtn.disabled = (currentStep === steps.length - 1);
                resetBtn.disabled = (currentStep === 0);
                
                if (currentStep === steps.length - 1) {
                    startBtn.disabled = true;
                } else if (!isPlaying) {
                    startBtn.disabled = false;
                }
            }

            function handleNext() {
                if (currentStep < steps.length - 1) {
                    renderStep(currentStep + 1);
                }
            }

            function handlePrev() {
                if (currentStep > 0) {
                    renderStep(currentStep - 1);
                }
            }
            
            function handleReset() {
                handlePause();
                
                let newSize = parseInt(gridSizeInput.value, 10);
                if (isNaN(newSize) || newSize < 3 || newSize > 51) {
                    newSize = 21;
                    gridSizeInput.value = "21";
                } else if (newSize % 2 === 0) {
                    newSize++;
                    if (newSize > 51) newSize = 51;
                    gridSizeInput.value = newSize.toString();
                }
                GRID_SIZE = newSize;
                
                // --- Dynamic Size Calculation ---
                const canvasContainer = canvas.parentElement;
                if (!canvasContainer) {
                    console.error("Canvas container not found!");
                    return;
                }
                
                // Debounced resize handler relies on this element being correct
                if (!canvasContainer.clientWidth) {
                    // This can happen if the element is hidden or not yet in DOM
                    // We can't resize, so we'll just wait for the next call.
                    return; 
                }
                
                const containerWidth = canvasContainer.clientWidth;
                const availableWidth = containerWidth - PADDING * 2;
                
                CELL_SPACING = Math.floor(availableWidth / (GRID_SIZE - 1));
                if (CELL_SPACING < 4) CELL_SPACING = 4;
                
                NODE_RADIUS = Math.max(2, Math.floor(CELL_SPACING / 3));
                if (NODE_RADIUS > 8) NODE_RADIUS = 8;
                
                START_NODE = { x: Math.floor(GRID_SIZE / 2), y: Math.floor(GRID_SIZE / 2) };
                CANVAS_WIDTH = (GRID_SIZE - 1) * CELL_SPACING + PADDING * 2;
                CANVAS_HEIGHT = CANVAS_WIDTH;
                // --- End Dynamic Size Calculation ---
                
                currentStep = 0;
                const strategy = strategySelect.value;
                generateDFSSteps(strategy);
                renderStep(0);
                startBtn.disabled = false;
            }

            function handleStart() {
                if (isPlaying) return;
                isPlaying = true;
                startBtn.disabled = true;
                pauseBtn.disabled = false;
                
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                resetBtn.disabled = true;
                strategySelect.disabled = true;
                gridSizeInput.disabled = true;

                autoPlayLoop();
            }

            function handlePause() {
                isPlaying = false;
                if (timeoutId) clearTimeout(timeoutId);
                timeoutId = null;
                
                pauseBtn.disabled = true;
                strategySelect.disabled = false;
                gridSizeInput.disabled = false; 
                renderStep(currentStep);
            }

            function autoPlayLoop() {
                if (!isPlaying) {
                    return;
                }
                
                if (currentStep >= steps.length - 1) {
                    handlePause();
                    renderStep(steps.length - 1);
                    return;
                }

                handleNext();
                timeoutId = setTimeout(autoPlayLoop, 50); 
            }

            // --- Event Listeners ---
            prevBtn.addEventListener('click', handlePrev);
            nextBtn.addEventListener('click', handleNext);
            resetBtn.addEventListener('click', handleReset);
            startBtn.addEventListener('click', handleStart);
            pauseBtn.addEventListener('click', handlePause);
            strategySelect.addEventListener('change', handleReset);
            gridSizeInput.addEventListener('change', handleReset);
            
            // --- Initial Setup ---
            
            // FIX for ResizeObserver loop: Debounce the reset function
            const debouncedReset = () => {
                // Check if canvas parent exists and has a width
                if (canvas.parentElement && canvas.parentElement.clientWidth > 0) {
                    handleReset();
                }
            };

            const observer = new ResizeObserver(entries => {
                clearTimeout(resizeTimer);
                if (entries[0].contentRect.width > 0) {
                     resizeTimer = setTimeout(debouncedReset, 150);
                }
            });
            
            if (canvas.parentElement) {
                observer.observe(canvas.parentElement);
            }
            
            // Initial call
            setTimeout(debouncedReset, 0); // Use setTimeout to let parent element render

        });
    </script>

</body>
</html>