<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>N-Body Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
        }
        
        #topBar {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 12px;
            z-index: 100;
            pointer-events: none;
            user-select: none;
            flex-wrap: wrap;
            max-width: 95vw;
        }
        .stats-item {
            color: rgba(255, 255, 255, 0.4);
            font-size: 10px;
            font-family: monospace;
            background: rgba(0,0,0,0.4);
            padding: 3px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        .stats-item.warning {
            color: #ff4444;
            border-color: #ff4444;
            background: rgba(255, 0, 0, 0.1);
        }
        .stats-item.highlight {
            color: #00ffaa;
            border-color: #00ffaa;
            background: rgba(0, 255, 150, 0.1);
        }
        
        #controls {
            position: absolute;
            top: 60px;
            left: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .control-group {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(8px);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .control-group label {
            color: rgba(255, 255, 255, 0.4);
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-right: 8px;
            width: 70px;
        }
        .control-group select, .control-group input[type="number"], .control-group input[type="checkbox"] {
            background: transparent;
            border: none;
            color: #fff;
            font-family: monospace;
            font-size: 11px;
            outline: none;
            padding: 0;
        }
        .control-group select {
            width: 110px;
            cursor: pointer;
        }
        .control-group select option {
            background: #222;
        }
        .control-group input[type="number"] {
            width: 45px;
        }
        .control-group input[type="range"] {
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            height: 2px;
            width: 60px;
            outline: none;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }
        .control-value-display {
            color: #fff;
            font-family: monospace;
            font-size: 10px;
            margin-left: 8px;
            min-width: 32px;
            text-align: right;
            opacity: 0.8;
        }

        .action-btns {
            display: grid; 
            grid-template-columns: 1fr 1fr;
            gap: 4px; 
            margin-top: 4px;
        }
        .action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            font-family: -apple-system, sans-serif;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
        }
        .action-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .action-btn.special { background: rgba(0, 150, 255, 0.2); border-color: rgba(0, 150, 255, 0.5); }
        #reverseBtn.reversing { background: rgba(255, 100, 0, 0.3); border-color: #ff6600; }
        #pauseBtn.paused { background: rgba(0, 255, 100, 0.15); border-color: rgba(0, 255, 100, 0.5); }

        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        #ui-hint {
            position: absolute;
            bottom: 15px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.2);
            font-size: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="topBar">
        <div id="fpsCounter" class="stats-item">FPS: --</div>
        <div id="simTimeCounter" class="stats-item">T: 0.00s</div>
        <div id="energyCounter" class="stats-item">E: --</div>
        <div id="driftCounter" class="stats-item">DRIFT: 0.000%</div>
        <div id="comCounter" class="stats-item">COM: (0,0)</div>
        <div id="reversalError" class="stats-item">REV ERR: --</div>
        <div id="zoomCounter" class="stats-item">ZOOM: --</div>
    </div>
    
    <div id="controls">
        <div class="control-group">
            <label for="schemeSelector">Scheme</label>
            <select id="schemeSelector">
                <option value="euler">Euler (Classic)</option>
                <option value="euler-cromer">Euler-Cromer</option>
                <option value="leapfrog-dkd">Leapfrog DKD</option>
                <option value="leapfrog-kdk" selected>Leapfrog KDK</option>
                <option value="velocity-verlet">Velocity Verlet</option>
                <option value="rk4">Runge-Kutta 4</option>
            </select>
        </div>
        <div class="control-group">
            <label for="numBodiesInput">Bodies</label>
            <input type="number" id="numBodiesInput" value="3" min="1" max="100">
        </div>
        <div class="control-group">
            <label for="softeningToggle">Softening</label>
            <input type="checkbox" id="softeningToggle">
        </div>
        <div class="control-group">
            <label for="virialKInput">Virial K</label>
            <input type="number" id="virialKInput" value="0.5" step="0.1" min="0">
        </div>
        <div class="control-group">
            <label for="speedScaleInput">Tail+</label>
            <input type="range" id="speedScaleInput" value="400" min="0" max="500">
            <span id="speedScaleValue" class="control-value-display">400</span>
        </div>
        <div class="control-group">
            <label for="dtInput">Step</label>
            <input type="range" id="dtInput" value="0.001" min="0.0001" max="0.01" step="0.0001">
            <span id="dtValue" class="control-value-display">0.001</span>
        </div>
        <div class="control-group">
            <label for="subStepsInput">Substeps</label>
            <input type="range" id="subStepsInput" value="1000" min="1" max="2000">
            <span id="subStepsValue" class="control-value-display">1000</span>
        </div>
        <div class="action-btns">
            <button id="pauseBtn" class="action-btn">Pause</button>
            <button id="resetBtn" class="action-btn">Reset</button>
            <button id="fig8Btn" class="action-btn special">Figure 8</button>
            <button id="reverseBtn" class="action-btn">Reverse</button>
            <button id="clearTrailsBtn" class="action-btn">Clear</button>
        </div>
    </div>

    <div id="ui-hint">N-body Simulation â€¢ Reversibility & Stability Test</div>

    <canvas id="mandalaCanvas"></canvas>

    <script>
        const canvas = document.getElementById('mandalaCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        const fpsDisplay = document.getElementById('fpsCounter');
        const simTimeDisplay = document.getElementById('simTimeCounter');
        const energyDisplay = document.getElementById('energyCounter');
        const driftDisplay = document.getElementById('driftCounter');
        const comDisplay = document.getElementById('comCounter');
        const revErrorDisplay = document.getElementById('reversalError');
        const zoomDisplay = document.getElementById('zoomCounter');
        
        const schemeSelector = document.getElementById('schemeSelector');
        const numBodiesInput = document.getElementById('numBodiesInput');
        const softeningToggle = document.getElementById('softeningToggle');
        const virialKInput = document.getElementById('virialKInput');
        const speedScaleInput = document.getElementById('speedScaleInput');
        const speedScaleValue = document.getElementById('speedScaleValue');
        const dtInput = document.getElementById('dtInput');
        const dtValue = document.getElementById('dtValue');
        const subStepsInput = document.getElementById('subStepsInput');
        const subStepsValue = document.getElementById('subStepsValue');
        const resetBtn = document.getElementById('resetBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const reverseBtn = document.getElementById('reverseBtn');
        const fig8Btn = document.getElementById('fig8Btn');
        const clearTrailsBtn = document.getElementById('clearTrailsBtn');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        
        const config = {
            scheme: 'leapfrog-kdk',
            numBodies: 3,           
            G: 250,                  
            softening: 0.0,         
            useSoftening: false,
            dt: 0.001,               
            subSteps: 1000,           
            trailLength: 2000,      
            minTadpoleLength: 10,    
            tadpoleSpeedScale: 400,   
            particleSize: 7,
            glowSize: 25,           
            zoom: 1.0,
            panX: 0,
            panY: 0,
            r0: 180,                
            virialK: 0.5,           
            orbitWidth: 2,
            orbitOpacity: 0.7,
            isPaused: false,
            isReversing: false,
            initialEnergy: 0,
            initialPositions: [],
            driftThreshold: 0.05,
            safetyCheckEnabled: true 
        };

        let bodies = [];
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let simulationTime = 0;

        // Interaction State
        let isDragging = false;
        let lastDragX = 0;
        let lastDragY = 0;

        class Body {
            constructor(x, y, vx, vy, hue) {
                this.x = x; this.y = y;
                this.vx = vx; this.vy = vy;
                this.ax = 0; this.ay = 0;
                this.mass = 1.0;
                this.trail = [];
                this.hue = hue;
                this.color = `hsl(${this.hue}, 100%, 65%)`;
                this.speed = 0;
            }

            pushTrail() {
                this.speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                this.trail.push({ x: this.x, y: this.y, speed: this.speed });
                if (this.trail.length > config.trailLength) this.trail.shift();
            }

            draw() {
                const len = this.trail.length;
                if (len < 2) return;
                ctx.beginPath();
                ctx.lineWidth = config.orbitWidth;
                ctx.strokeStyle = `hsla(${this.hue}, 100%, 60%, ${config.orbitOpacity})`;
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                const step = len > 2000 ? 4 : 2;
                for (let i = 1; i < len; i += step) ctx.lineTo(this.trail[i].x, this.trail[i].y);
                ctx.stroke();

                const currentPoint = this.trail[len - 1];
                const dynLen = Math.floor(config.minTadpoleLength + (currentPoint?.speed || 0) * (config.tadpoleSpeedScale / 5));
                const tStart = Math.max(0, len - dynLen);
                const actualSegs = len - tStart;
                for (let i = len - 1; i > tStart; i--) {
                    const ratio = (i - tStart) / (actualSegs || 1);
                    const fade = Math.pow(ratio, 1.5);
                    ctx.beginPath();
                    ctx.lineCap = 'round';
                    ctx.lineWidth = (config.particleSize * 2.2) * fade;
                    ctx.strokeStyle = `hsla(${this.hue}, 100%, 75%, ${fade * 0.75})`;
                    ctx.moveTo(this.trail[i].x, this.trail[i].y);
                    ctx.lineTo(this.trail[i-1].x, this.trail[i-1].y);
                    ctx.stroke();
                }
                ctx.save();
                ctx.shadowBlur = config.glowSize;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color.replace('65%', '95%');
                ctx.beginPath();
                ctx.arc(this.x, this.y, config.particleSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function getSoftVal() {
            return config.useSoftening ? 1.5 : 0.0;
        }

        function calculateEnergyAndCOM() {
            let totalKinetic = 0;
            let totalPotential = 0;
            let sumMX = 0;
            let sumMY = 0;
            let totalMass = 0;
            const soft = getSoftVal();

            for (let i = 0; i < bodies.length; i++) {
                const b1 = bodies[i];
                totalKinetic += 0.5 * b1.mass * (b1.vx * b1.vx + b1.vy * b1.vy);
                sumMX += b1.mass * b1.x;
                sumMY += b1.mass * b1.y;
                totalMass += b1.mass;

                for (let j = i + 1; j < bodies.length; j++) {
                    const b2 = bodies[j];
                    const dx = b2.x - b1.x;
                    const dy = b2.y - b1.y;
                    const distSq = dx * dx + dy * dy + soft;
                    totalPotential -= (config.G * b1.mass * b2.mass) / Math.sqrt(distSq);
                }
            }

            return {
                total: totalKinetic + totalPotential,
                comX: sumMX / (totalMass || 1),
                comY: sumMY / (totalMass || 1)
            };
        }

        function drawCOM(x, y) {
            ctx.save();
            ctx.shadowBlur = config.glowSize;
            ctx.shadowColor = "rgba(255, 0, 0, 1)";
            ctx.fillStyle = "rgba(255, 50, 50, 1)";
            ctx.beginPath();
            ctx.arc(x, y, config.particleSize / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function getAccels() {
            bodies.forEach(b => { b.ax = 0; b.ay = 0; });
            const soft = getSoftVal();
            for (let i = 0; i < bodies.length; i++) {
                const b1 = bodies[i];
                for (let j = i + 1; j < bodies.length; j++) {
                    const b2 = bodies[j];
                    const dx = b2.x - b1.x;
                    const dy = b2.y - b1.y;
                    let d2 = dx*dx + dy*dy;
                    if (d2 === 0 && soft === 0) d2 = 0.000001; 
                    const d2soft = d2 + soft;
                    const invD3 = 1.0 / (d2soft * Math.sqrt(d2soft));
                    const fx = dx * config.G * invD3; 
                    const fy = dy * config.G * invD3;
                    b1.ax += fx; b1.ay += fy;
                    b2.ax -= fx; b2.ay -= fy;
                }
            }
        }

        function stepSimulation() {
            const dt = config.dt;
            switch(config.scheme) {
                case 'euler':
                    getAccels();
                    bodies.forEach(b => {
                        b.x += b.vx * dt; b.y += b.vy * dt;
                        b.vx += b.ax * dt; b.vy += b.ay * dt;
                    });
                    break;
                case 'euler-cromer':
                    getAccels();
                    bodies.forEach(b => {
                        b.vx += b.ax * dt; b.vy += b.ay * dt;
                        b.x += b.vx * dt; b.y += b.vy * dt;
                    });
                    break;
                case 'velocity-verlet':
                    bodies.forEach(b => {
                        b.vx += 0.5 * b.ax * dt; b.vy += 0.5 * b.ay * dt;
                        b.x += b.vx * dt; b.y += b.vy * dt;
                    });
                    getAccels();
                    bodies.forEach(b => {
                        b.vx += 0.5 * b.ax * dt; b.vy += 0.5 * b.ay * dt;
                    });
                    break;
                case 'leapfrog-dkd':
                    bodies.forEach(b => { b.x += b.vx * (dt/2); b.y += b.vy * (dt/2); });
                    getAccels();
                    bodies.forEach(b => { b.vx += b.ax * dt; b.vy += b.ay * dt; });
                    bodies.forEach(b => { b.x += b.vx * (dt/2); b.y += b.vy * (dt/2); });
                    break;
                case 'leapfrog-kdk':
                    bodies.forEach(b => { b.vx += b.ax * (dt/2); b.vy += b.ay * (dt/2); });
                    bodies.forEach(b => { b.x += b.vx * dt; b.y += b.vy * dt; });
                    getAccels();
                    bodies.forEach(b => { b.vx += b.ax * (dt/2); b.vy += b.ay * (dt/2); });
                    break;
                case 'rk4':
                    const x0 = bodies.map(b => ({x: b.x, y: b.y}));
                    const v0 = bodies.map(b => ({x: b.vx, y: b.vy}));
                    getAccels();
                    const k1v = bodies.map(b => ({x: b.ax, y: b.ay}));
                    const k1x = v0;
                    bodies.forEach((b, i) => {
                        b.x = x0[i].x + k1x[i].x * dt * 0.5;
                        b.y = x0[i].y + k1x[i].y * dt * 0.5;
                    });
                    getAccels();
                    const k2v = bodies.map(b => ({x: b.ax, y: b.ay}));
                    const k2x = bodies.map((b, i) => ({x: v0[i].x + k1v[i].x * dt * 0.5, y: v0[i].y + k1v[i].y * dt * 0.5}));
                    bodies.forEach((b, i) => {
                        b.x = x0[i].x + k2x[i].x * dt * 0.5;
                        b.y = x0[i].y + k2x[i].y * dt * 0.5;
                    });
                    getAccels();
                    const k3v = bodies.map(b => ({x: b.ax, y: b.ay}));
                    const k3x = bodies.map((b, i) => ({x: v0[i].x + k2v[i].x * dt * 0.5, y: v0[i].y + k2v[i].y * dt * 0.5}));
                    bodies.forEach((b, i) => {
                        b.x = x0[i].x + k3x[i].x * dt;
                        b.y = x0[i].y + k3x[i].y * dt;
                    });
                    getAccels();
                    const k4v = bodies.map(b => ({x: b.ax, y: b.ay}));
                    const k4x = bodies.map((b, i) => ({x: v0[i].x + k3v[i].x * dt, y: v0[i].y + k3v[i].y * dt}));
                    bodies.forEach((b, i) => {
                        b.x = x0[i].x + (dt/6) * (k1x[i].x + 2*k2x[i].x + 2*k3x[i].x + k4x[i].x);
                        b.y = x0[i].y + (dt/6) * (k1x[i].y + 2*k2x[i].y + 2*k3x[i].y + k4x[i].y);
                        b.vx = v0[i].x + (dt/6) * (k1v[i].x + 2*k2v[i].x + 2*k3v[i].x + k4v[i].x);
                        b.vy = v0[i].y + (dt/6) * (k1v[i].y + 2*k2v[i].y + 2*k3v[i].y + k4v[i].y);
                    });
                    break;
            }
            simulationTime += config.isReversing ? -dt : dt;
        }

        function initSimulation() {
            config.scheme = schemeSelector.value;
            config.numBodies = parseInt(numBodiesInput.value) || 1;
            config.virialK = parseFloat(virialKInput.value);
            config.tadpoleSpeedScale = parseInt(speedScaleInput.value);
            config.trailLength = 500 + (config.tadpoleSpeedScale * 10);
            config.dt = parseFloat(dtInput.value);
            config.subSteps = parseInt(subStepsInput.value);
            config.useSoftening = softeningToggle.checked;
            
            config.isPaused = false;
            config.isReversing = false;
            reverseBtn.classList.remove('reversing');
            reverseBtn.textContent = "Reverse";
            
            pauseBtn.textContent = 'Pause';
            pauseBtn.classList.remove('paused');
            driftDisplay.classList.remove('warning');
            revErrorDisplay.textContent = "REV ERR: --";
            revErrorDisplay.classList.remove('highlight');
            
            simulationTime = 0; 
            bodies = [];

            const n = config.numBodies;
            const r0 = config.r0;
            for (let i = 0; i < n; i++) {
                const theta = (i / n) * Math.PI * 2;
                bodies.push(new Body(r0 * Math.cos(theta), r0 * Math.sin(theta), 0, 0, (i / n) * 360));
            }
            
            const soft = getSoftVal();
            let sumInvDist = 0;
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const dx = bodies[i].x - bodies[j].x;
                    const dy = bodies[i].y - bodies[j].y;
                    sumInvDist += 1 / Math.sqrt(dx*dx + dy*dy + soft);
                }
            }
            
            const v0 = config.virialK * Math.sqrt((config.G * sumInvDist) / (n || 1));
            bodies.forEach((b, i) => {
                const theta = (i / n) * Math.PI * 2;
                b.vx = -v0 * Math.sin(theta);
                b.vy = v0 * Math.cos(theta);
            });
            
            getAccels();
            const { total } = calculateEnergyAndCOM();
            config.initialEnergy = total;
            config.initialPositions = bodies.map(b => ({x: b.x, y: b.y}));
        }

        function initFigure8() {
            config.numBodies = 3;
            numBodiesInput.value = 3;
            config.useSoftening = false;
            softeningToggle.checked = false;
            
            config.isPaused = false;
            config.isReversing = false;
            reverseBtn.classList.remove('reversing');
            reverseBtn.textContent = "Reverse";
            pauseBtn.textContent = 'Pause';
            pauseBtn.classList.remove('paused');
            driftDisplay.classList.remove('warning');
            revErrorDisplay.textContent = "REV ERR: --";
            
            simulationTime = 0; 
            bodies = [];

            const posScale = 180; 
            const G_val = config.G;
            
            const r1 = { x: 0.9700436, y: -0.24308753 };
            const v1 = { x: 0.466203685, y: 0.43236573 };
            
            const vScale = Math.sqrt(G_val / posScale);
            
            bodies.push(new Body(r1.x * posScale, r1.y * posScale, v1.x * vScale, v1.y * vScale, 0));
            bodies.push(new Body(-r1.x * posScale, -r1.y * posScale, v1.x * vScale, v1.y * vScale, 120));
            bodies.push(new Body(0, 0, -2 * v1.x * vScale, -2 * v1.y * vScale, 240));

            getAccels();
            const { total } = calculateEnergyAndCOM();
            config.initialEnergy = total;
            config.initialPositions = bodies.map(b => ({x: b.x, y: b.y}));
        }

        // --- UI & Interaction ---

        window.addEventListener('wheel', (e) => {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT') {
                e.preventDefault();
                config.zoom *= Math.pow(0.999, e.deltaY);
                config.zoom = Math.min(Math.max(config.zoom, 0.0001), 100);
            }
        }, { passive: false });

        window.addEventListener('mousedown', (e) => {
            if (!['INPUT', 'SELECT', 'BUTTON'].includes(e.target.tagName)) {
                isDragging = true;
                lastDragX = e.clientX;
                lastDragY = e.clientY;
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                config.panX += e.clientX - lastDragX;
                config.panY += e.clientY - lastDragY;
                lastDragX = e.clientX;
                lastDragY = e.clientY;
            }
        });

        window.addEventListener('mouseup', () => isDragging = false);

        schemeSelector.addEventListener('change', () => config.scheme = schemeSelector.value);
        softeningToggle.addEventListener('change', () => {
            config.useSoftening = softeningToggle.checked;
            const { total } = calculateEnergyAndCOM();
            config.initialEnergy = total;
        });
        numBodiesInput.addEventListener('change', initSimulation);
        virialKInput.addEventListener('change', initSimulation);

        resetBtn.addEventListener('click', initSimulation);
        fig8Btn.addEventListener('click', initFigure8);
        clearTrailsBtn.addEventListener('click', () => bodies.forEach(b => b.trail = []));
        
        pauseBtn.addEventListener('click', () => {
            config.isPaused = !config.isPaused;
            pauseBtn.textContent = config.isPaused ? 'Resume' : 'Pause';
            pauseBtn.classList.toggle('paused', config.isPaused);
        });

        reverseBtn.addEventListener('click', () => {
            bodies.forEach(b => { b.vx = -b.vx; b.vy = -b.vy; });
            config.isReversing = !config.isReversing;
            reverseBtn.classList.toggle('reversing', config.isReversing);
            reverseBtn.textContent = config.isReversing ? "Forward" : "Reverse";
        });

        speedScaleInput.addEventListener('input', () => {
            config.tadpoleSpeedScale = parseInt(speedScaleInput.value);
            config.trailLength = 500 + (config.tadpoleSpeedScale * 10);
            speedScaleValue.textContent = speedScaleInput.value;
        });
        dtInput.addEventListener('input', () => { config.dt = parseFloat(dtInput.value); dtValue.textContent = config.dt.toFixed(4); });
        subStepsInput.addEventListener('input', () => { config.subSteps = parseInt(subStepsInput.value); subStepsValue.textContent = subStepsInput.value; });

        function render(now) {
            if (now - lastFpsUpdate > 500) {
                fpsDisplay.textContent = `FPS: ${Math.round((frameCount * 1000) / (now - lastFpsUpdate))}`;
                lastFpsUpdate = now;
                frameCount = 0;
            }
            frameCount++;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            if (!config.isPaused) {
                for (let s = 0; s < config.subSteps; s++) {
                    stepSimulation();
                }
                bodies.forEach(b => b.pushTrail());
            }

            const { total, comX, comY } = calculateEnergyAndCOM();
            const driftPerc = Math.abs((total - config.initialEnergy) / (config.initialEnergy || 1)) * 100;
            
            simTimeDisplay.textContent = `T: ${simulationTime.toFixed(2)}s`;
            energyDisplay.textContent = `E: ${total.toFixed(4)}`;
            driftDisplay.textContent = `DRIFT: ${driftPerc.toFixed(3)}%`;
            comDisplay.textContent = `COM: (${comX.toFixed(2)}, ${comY.toFixed(2)})`;
            zoomDisplay.textContent = `ZOOM: ${config.zoom.toFixed(2)}x`;

            if (driftPerc > config.driftThreshold * 100) driftDisplay.classList.add('warning');
            else driftDisplay.classList.remove('warning');

            if (config.isReversing && Math.abs(simulationTime) < 0.05) {
                let err = 0;
                bodies.forEach((b, i) => {
                    err += Math.sqrt((b.x - config.initialPositions[i].x)**2 + (b.y - config.initialPositions[i].y)**2);
                });
                revErrorDisplay.textContent = `REV ERR: ${err.toFixed(4)}`;
                revErrorDisplay.classList.add('highlight');
            } else if (!config.isReversing) {
                revErrorDisplay.classList.remove('highlight');
            }

            ctx.save();
            ctx.translate(width / 2 + config.panX, height / 2 + config.panY);
            ctx.scale(config.zoom, config.zoom);
            drawCOM(comX, comY);
            bodies.forEach(b => b.draw());
            ctx.restore();
            
            requestAnimationFrame(render);
        }

        window.addEventListener('resize', () => { 
            width = canvas.width = window.innerWidth; 
            height = canvas.height = window.innerHeight; 
            initSimulation(); 
        });
        
        initSimulation();
        requestAnimationFrame(render);
    </script>
</body>
</html>
