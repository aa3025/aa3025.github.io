<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>N-Body Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
        }
        
        #topBar {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            gap: 12px;
            z-index: 100;
            pointer-events: none;
            user-select: none;
            flex-wrap: wrap;
            max-width: 95vw;
        }
        .stats-item {
            color: rgba(255, 255, 255, 0.4);
            font-size: 10px;
            font-family: monospace;
            background: rgba(0,0,0,0.4);
            padding: 3px 6px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }
        .stats-item.warning {
            color: #ff4444;
            border-color: #ff4444;
            background: rgba(255, 0, 0, 0.1);
        }
        
        #controls {
            position: absolute;
            top: 60px;
            left: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .control-group {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(8px);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .control-group label {
            color: rgba(255, 255, 255, 0.4);
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-right: 8px;
            width: 55px;
        }
        .control-group select, .control-group input[type="number"] {
            background: transparent;
            border: none;
            color: #fff;
            font-family: monospace;
            font-size: 11px;
            outline: none;
            padding: 0;
        }
        .control-group select {
            width: 110px;
            cursor: pointer;
        }
        .control-group select option {
            background: #222;
        }
        .control-group input[type="number"] {
            width: 35px;
        }
        .control-group input[type="range"] {
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.1);
            height: 2px;
            width: 60px;
            outline: none;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }
        .control-value-display {
            color: #fff;
            font-family: monospace;
            font-size: 10px;
            margin-left: 8px;
            min-width: 32px;
            text-align: right;
            opacity: 0.8;
        }

        .action-btns {
            display: flex; 
            gap: 4px; 
            margin-top: 4px;
        }
        .action-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            font-family: -apple-system, sans-serif;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: all 0.2s;
            flex: 1;
        }
        .action-btn:hover { background: rgba(255, 255, 255, 0.2); }
        #pauseBtn.paused { background: rgba(0, 255, 100, 0.15); border-color: rgba(0, 255, 100, 0.5); }

        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        #ui-hint {
            position: absolute;
            bottom: 15px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.2);
            font-size: 10px;
            letter-spacing: 1px;
            text-transform: uppercase;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="topBar">
        <div id="fpsCounter" class="stats-item">FPS: --</div>
        <div id="simTimeCounter" class="stats-item">T: 0.00s</div>
        <div id="energyCounter" class="stats-item">E: --</div>
        <div id="driftCounter" class="stats-item">DRIFT: 0.000%</div>
        <div id="comCounter" class="stats-item">COM: (0,0)</div>
    </div>
    
    <div id="controls">
        <div class="control-group">
            <label for="schemeSelector">Scheme</label>
            <select id="schemeSelector">
                <option value="euler">Euler (Classic)</option>
                <option value="euler-cromer" selected>Euler-Cromer</option>
                <option value="leapfrog-dkd">Leapfrog DKD</option>
                <option value="leapfrog-kdk">Leapfrog KDK</option>
                <option value="velocity-verlet">Velocity Verlet</option>
                <option value="rk4">Runge-Kutta 4</option>
            </select>
        </div>
        <div class="control-group">
            <label for="numBodiesInput">Bodies</label>
            <input type="number" id="numBodiesInput" value="3" min="2" max="64">
        </div>
        <div class="control-group">
            <label for="virialKInput">Virial K</label>
            <input type="number" id="virialKInput" value="0.5" step="0.1" min="0">
        </div>
        <div class="control-group">
            <label for="speedScaleInput">Tail+</label>
            <input type="range" id="speedScaleInput" value="400" min="0" max="500">
            <span id="speedScaleValue" class="control-value-display">200</span>
        </div>
        <div class="control-group">
            <label for="dtInput">Step</label>
            <input type="range" id="dtInput" value="0.1" min="0.001" max="0.2" step="0.001">
            <span id="dtValue" class="control-value-display">0.100</span>
        </div>
        <div class="control-group">
            <label for="subStepsInput">Substeps</label>
            <input type="range" id="subStepsInput" value="10" min="1" max="1000">
            <span id="subStepsValue" class="control-value-display">10</span>
        </div>
        <div class="action-btns">
            <button id="pauseBtn" class="action-btn">Pause</button>
            <button id="resetBtn" class="action-btn">Reset</button>
        </div>
    </div>

    <div id="ui-hint">N-body Simulation â€¢ Mouse Wheel to Zoom</div>

    <canvas id="mandalaCanvas"></canvas>

    <script>
        const canvas = document.getElementById('mandalaCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        
        const fpsDisplay = document.getElementById('fpsCounter');
        const simTimeDisplay = document.getElementById('simTimeCounter');
        const energyDisplay = document.getElementById('energyCounter');
        const driftDisplay = document.getElementById('driftCounter');
        const comDisplay = document.getElementById('comCounter');
        
        const schemeSelector = document.getElementById('schemeSelector');
        const numBodiesInput = document.getElementById('numBodiesInput');
        const virialKInput = document.getElementById('virialKInput');
        const speedScaleInput = document.getElementById('speedScaleInput');
        const speedScaleValue = document.getElementById('speedScaleValue');
        const dtInput = document.getElementById('dtInput');
        const dtValue = document.getElementById('dtValue');
        const subStepsInput = document.getElementById('subStepsInput');
        const subStepsValue = document.getElementById('subStepsValue');
        const resetBtn = document.getElementById('resetBtn');
        const pauseBtn = document.getElementById('pauseBtn');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        
        const config = {
            scheme: 'euler-cromer',
            numBodies: 3,           
            G: 250,                 
            softening: 1.0,         
            dt: 0.1,               
            subSteps: 10,           
            trailLength: 2000,      
            minTadpoleLength: 10,    
            tadpoleSpeedScale: 200,   
            particleSize: 7,
            glowSize: 25,           
            zoom: 0.6,
            damping: 1.0,           
            r0: 180,                
            virialK: 0.5,           
            orbitWidth: 2,
            orbitOpacity: 0.7,
            isPaused: false,
            initialEnergy: 0,
            driftThreshold: 0.01 // 1%
        };

        let bodies = [];
        let frameCount = 0;
        let lastFpsUpdate = 0;
        let simulationTime = 0;

        class Body {
            constructor(x, y, vx, vy, hue) {
                this.x = x; this.y = y;
                this.vx = vx; this.vy = vy;
                this.ax = 0; this.ay = 0;
                this.mass = 1.0;
                this.trail = [];
                this.hue = hue;
                this.color = `hsl(${this.hue}, 100%, 65%)`;
                this.speed = 0;
            }

            pushTrail() {
                this.speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                this.trail.push({ x: this.x, y: this.y, speed: this.speed });
                if (this.trail.length > config.trailLength) this.trail.shift();
            }

            draw() {
                const len = this.trail.length;
                if (len < 2) return;
                ctx.beginPath();
                ctx.lineWidth = config.orbitWidth;
                ctx.strokeStyle = `hsla(${this.hue}, 100%, 60%, ${config.orbitOpacity})`;
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                const step = len > 2000 ? 4 : 2;
                for (let i = 1; i < len; i += step) ctx.lineTo(this.trail[i].x, this.trail[i].y);
                ctx.stroke();

                const currentPoint = this.trail[len - 1];
                const dynLen = Math.floor(config.minTadpoleLength + (currentPoint?.speed || 0) * (config.tadpoleSpeedScale / 5));
                const tStart = Math.max(0, len - dynLen);
                const actualSegs = len - tStart;
                for (let i = len - 1; i > tStart; i--) {
                    const ratio = (i - tStart) / (actualSegs || 1);
                    const fade = Math.pow(ratio, 1.5);
                    ctx.beginPath();
                    ctx.lineCap = 'round';
                    ctx.lineWidth = (config.particleSize * 2.2) * fade;
                    ctx.strokeStyle = `hsla(${this.hue}, 100%, 75%, ${fade * 0.75})`;
                    ctx.moveTo(this.trail[i].x, this.trail[i].y);
                    ctx.lineTo(this.trail[i-1].x, this.trail[i-1].y);
                    ctx.stroke();
                }
                ctx.save();
                ctx.shadowBlur = config.glowSize;
                ctx.shadowColor = this.color;
                ctx.fillStyle = this.color.replace('65%', '95%');
                ctx.beginPath();
                ctx.arc(this.x, this.y, config.particleSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function calculateEnergyAndCOM() {
            let totalKinetic = 0;
            let totalPotential = 0;
            let sumMX = 0;
            let sumMY = 0;
            let totalMass = 0;

            for (let i = 0; i < bodies.length; i++) {
                const b1 = bodies[i];
                totalKinetic += 0.5 * b1.mass * (b1.vx * b1.vx + b1.vy * b1.vy);
                sumMX += b1.mass * b1.x;
                sumMY += b1.mass * b1.y;
                totalMass += b1.mass;

                for (let j = i + 1; j < bodies.length; j++) {
                    const b2 = bodies[j];
                    const dx = b2.x - b1.x;
                    const dy = b2.y - b1.y;
                    const distSq = dx * dx + dy * dy + config.softening;
                    totalPotential -= (config.G * b1.mass * b2.mass) / Math.sqrt(distSq);
                }
            }

            return {
                total: totalKinetic + totalPotential,
                comX: sumMX / totalMass,
                comY: sumMY / totalMass
            };
        }

        function drawCOM(x, y) {
            ctx.save();
            ctx.shadowBlur = config.glowSize;
            ctx.shadowColor = "rgba(255, 0, 0, 1)";
            ctx.fillStyle = "rgba(255, 50, 50, 1)";
            ctx.beginPath();
            ctx.arc(x, y, config.particleSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function getAccels() {
            bodies.forEach(b => { b.ax = 0; b.ay = 0; });
            for (let i = 0; i < bodies.length; i++) {
                const b1 = bodies[i];
                for (let j = i + 1; j < bodies.length; j++) {
                    const b2 = bodies[j];
                    const dx = b2.x - b1.x;
                    const dy = b2.y - b1.y;
                    const d2 = dx*dx + dy*dy + config.softening;
                    const invD3 = 1.0 / (d2 * Math.sqrt(d2));
                    const fx = dx * config.G * invD3; 
                    const fy = dy * config.G * invD3;
                    b1.ax += fx; b1.ay += fy;
                    b2.ax -= fx; b2.ay -= fy;
                }
            }
        }

        function stepSimulation() {
            const dt = config.dt;
            switch(config.scheme) {
                case 'euler':
                    getAccels();
                    bodies.forEach(b => {
                        b.x += b.vx * dt; b.y += b.vy * dt;
                        b.vx += b.ax * dt; b.vy += b.ay * dt;
                    });
                    break;
                case 'euler-cromer':
                    getAccels();
                    bodies.forEach(b => {
                        b.vx += b.ax * dt; b.vy += b.ay * dt;
                        b.x += b.vx * dt; b.y += b.vy * dt;
                    });
                    break;
                case 'velocity-verlet':
                    bodies.forEach(b => {
                        b.vx += 0.5 * b.ax * dt; b.vy += 0.5 * b.ay * dt;
                        b.x += b.vx * dt; b.y += b.vy * dt;
                    });
                    getAccels();
                    bodies.forEach(b => {
                        b.vx += 0.5 * b.ax * dt; b.vy += 0.5 * b.ay * dt;
                    });
                    break;
                case 'leapfrog-dkd':
                    bodies.forEach(b => { b.x += b.vx * (dt/2); b.y += b.vy * (dt/2); });
                    getAccels();
                    bodies.forEach(b => { b.vx += b.ax * dt; b.vy += b.ay * dt; });
                    bodies.forEach(b => { b.x += b.vx * (dt/2); b.y += b.vy * (dt/2); });
                    break;
                case 'leapfrog-kdk':
                    bodies.forEach(b => { b.vx += b.ax * (dt/2); b.vy += b.ay * (dt/2); });
                    bodies.forEach(b => { b.x += b.vx * dt; b.y += b.vy * dt; });
                    getAccels();
                    bodies.forEach(b => { b.vx += b.ax * (dt/2); b.vy += b.ay * (dt/2); });
                    break;
                case 'rk4':
                    const x0 = bodies.map(b => ({x: b.x, y: b.y}));
                    const v0 = bodies.map(b => ({x: b.vx, y: b.vy}));

                    getAccels();
                    const k1v = bodies.map(b => ({x: b.ax, y: b.ay}));
                    const k1x = v0;

                    bodies.forEach((b, i) => {
                        b.x = x0[i].x + k1x[i].x * dt * 0.5;
                        b.y = x0[i].y + k1x[i].y * dt * 0.5;
                    });
                    getAccels();
                    const k2v = bodies.map(b => ({x: b.ax, y: b.ay}));
                    const k2x = bodies.map((b, i) => ({x: v0[i].x + k1v[i].x * dt * 0.5, y: v0[i].y + k1v[i].y * dt * 0.5}));

                    bodies.forEach((b, i) => {
                        b.x = x0[i].x + k2x[i].x * dt * 0.5;
                        b.y = x0[i].y + k2x[i].y * dt * 0.5;
                    });
                    getAccels();
                    const k3v = bodies.map(b => ({x: b.ax, y: b.ay}));
                    const k3x = bodies.map((b, i) => ({x: v0[i].x + k2v[i].x * dt * 0.5, y: v0[i].y + k2v[i].y * dt * 0.5}));

                    bodies.forEach((b, i) => {
                        b.x = x0[i].x + k3x[i].x * dt;
                        b.y = x0[i].y + k3x[i].y * dt;
                    });
                    getAccels();
                    const k4v = bodies.map(b => ({x: b.ax, y: b.ay}));
                    const k4x = bodies.map((b, i) => ({x: v0[i].x + k3v[i].x * dt, y: v0[i].y + k3v[i].y * dt}));

                    bodies.forEach((b, i) => {
                        b.x = x0[i].x + (dt/6) * (k1x[i].x + 2*k2x[i].x + 2*k3x[i].x + k4x[i].x);
                        b.y = x0[i].y + (dt/6) * (k1x[i].y + 2*k2x[i].y + 2*k3x[i].y + k4x[i].y);
                        b.vx = v0[i].x + (dt/6) * (k1v[i].x + 2*k2v[i].x + 2*k3v[i].x + k4v[i].x);
                        b.vy = v0[i].y + (dt/6) * (k1v[i].y + 2*k2v[i].y + 2*k3v[i].y + k4v[i].y);
                    });
                    break;
            }
            simulationTime += dt;
        }

        function initSimulation() {
            config.scheme = schemeSelector.value;
            config.numBodies = parseInt(numBodiesInput.value) || 12;
            config.virialK = parseFloat(virialKInput.value) || 1.1;
            config.tadpoleSpeedScale = parseInt(speedScaleInput.value);
            config.trailLength = 500 + (config.tadpoleSpeedScale * 10);
            config.dt = parseFloat(dtInput.value);
            config.subSteps = parseInt(subStepsInput.value) || 10;
            config.isPaused = false;
            
            pauseBtn.textContent = 'Pause';
            pauseBtn.classList.remove('paused');
            driftDisplay.classList.remove('warning');
            
            simulationTime = 0; 
            bodies = [];

            const n = config.numBodies;
            const r0 = config.r0;
            for (let i = 0; i < n; i++) {
                const theta = (i / n) * Math.PI * 2;
                bodies.push(new Body(r0 * Math.cos(theta), r0 * Math.sin(theta), 0, 0, (i / n) * 360));
            }
            
            let sumInvDist = 0;
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const dx = bodies[i].x - bodies[j].x;
                    const dy = bodies[i].y - bodies[j].y;
                    sumInvDist += 1 / Math.sqrt(dx*dx + dy*dy + config.softening);
                }
            }
            
            const v0 = config.virialK * Math.sqrt((config.G * sumInvDist) / n);
            bodies.forEach((b, i) => {
                const theta = (i / n) * Math.PI * 2;
                b.vx = -v0 * Math.sin(theta);
                b.vy = v0 * Math.cos(theta);
            });
            
            getAccels();
            const { total } = calculateEnergyAndCOM();
            config.initialEnergy = total;
        }

        window.addEventListener('wheel', (e) => {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT') {
                e.preventDefault();
                const factor = Math.pow(0.999, e.deltaY);
                config.zoom *= factor;
                config.zoom = Math.min(Math.max(config.zoom, 0.0001), 100);
            }
        }, { passive: false });

        schemeSelector.addEventListener('change', initSimulation);
        [numBodiesInput, virialKInput].forEach(input => {
            input.addEventListener('change', initSimulation);
            input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { initSimulation(); input.blur(); } });
        });
        resetBtn.addEventListener('click', initSimulation);
        pauseBtn.addEventListener('click', () => {
            config.isPaused = !config.isPaused;
            pauseBtn.textContent = config.isPaused ? 'Resume' : 'Pause';
            pauseBtn.classList.toggle('paused', config.isPaused);
        });
        speedScaleInput.addEventListener('input', () => {
            config.tadpoleSpeedScale = parseInt(speedScaleInput.value);
            config.trailLength = 500 + (config.tadpoleSpeedScale * 10);
            speedScaleValue.textContent = speedScaleInput.value;
        });
        dtInput.addEventListener('input', () => { config.dt = parseFloat(dtInput.value); dtValue.textContent = config.dt.toFixed(3); });
        subStepsInput.addEventListener('input', () => { config.subSteps = parseInt(subStepsInput.value); subStepsValue.textContent = subStepsInput.value; });

        function render(now) {
            if (now - lastFpsUpdate > 500) {
                fpsDisplay.textContent = `FPS: ${Math.round((frameCount * 1000) / (now - lastFpsUpdate))}`;
                lastFpsUpdate = now;
                frameCount = 0;
            }
            frameCount++;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            if (!config.isPaused) {
                // RUN PHYSICS SUBSTEPS WITH SAFETY CHECKS INSIDE THE LOOP
                for (let s = 0; s < config.subSteps; s++) {
                    stepSimulation();
                    
                    // Frequent stability check for high substep values
                    if (s % 5 === 0) { 
                        const { total } = calculateEnergyAndCOM();
                        const drift = Math.abs((total - config.initialEnergy) / config.initialEnergy);
                        
                        // Safety pause if drift > 1% OR if numbers explode (NaN/Infinity)
                        if (drift > config.driftThreshold || !isFinite(total)) {
                            config.isPaused = true;
                            pauseBtn.textContent = 'Exploded (Resume?)';
                            pauseBtn.classList.add('paused');
                            driftDisplay.classList.add('warning');
                            break; 
                        }
                    }
                }
                bodies.forEach(b => b.pushTrail());
            }

            const { total, comX, comY } = calculateEnergyAndCOM();
            const driftPerc = Math.abs((total - config.initialEnergy) / config.initialEnergy) * 100;
            
            simTimeDisplay.textContent = `T: ${simulationTime.toFixed(2)}s`;
            energyDisplay.textContent = `E: ${total.toFixed(6)}`;
            driftDisplay.textContent = `DRIFT: ${driftPerc.toFixed(3)}%`;
            comDisplay.textContent = `COM: (${comX.toFixed(2)}, ${comY.toFixed(2)})`;

            ctx.save();
            ctx.translate(width / 2, height / 2);
            ctx.scale(config.zoom, config.zoom);
            drawCOM(comX, comY);
            bodies.forEach(b => b.draw());
            ctx.restore();
            
            requestAnimationFrame(render);
        }

        window.addEventListener('resize', () => { 
            width = canvas.width = window.innerWidth; 
            height = canvas.height = window.innerHeight; 
            initSimulation(); 
        });
        
        initSimulation();
        requestAnimationFrame(render);
    </script>
</body>
</html>
